/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"

#import "EDAMUserStore.h"
#import "EDAMTypes.h"
#import "EDAMErrors.h"
#import "EDAMLimits.h"

#import "EDAMNoteStore.h"

@implementation EDAMSyncState

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithCurrentTime: (EDAMTimestamp) currentTime fullSyncBefore: (EDAMTimestamp) fullSyncBefore updateCount: (int32_t) updateCount uploaded: (int64_t) uploaded
{
  self = [super init];
  __currentTime = currentTime;
  __currentTime_isset = YES;
  __fullSyncBefore = fullSyncBefore;
  __fullSyncBefore_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  __uploaded = uploaded;
  __uploaded_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"currentTime"])
  {
    __currentTime = [decoder decodeInt64ForKey: @"currentTime"];
    __currentTime_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncBefore"])
  {
    __fullSyncBefore = [decoder decodeInt64ForKey: @"fullSyncBefore"];
    __fullSyncBefore_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"uploaded"])
  {
    __uploaded = [decoder decodeInt64ForKey: @"uploaded"];
    __uploaded_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__currentTime_isset)
  {
    [encoder encodeInt64: __currentTime forKey: @"currentTime"];
  }
  if (__fullSyncBefore_isset)
  {
    [encoder encodeInt64: __fullSyncBefore forKey: @"fullSyncBefore"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
  if (__uploaded_isset)
  {
    [encoder encodeInt64: __uploaded forKey: @"uploaded"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (int64_t) currentTime {
  return __currentTime;
}

- (void) setCurrentTime: (int64_t) currentTime {
  __currentTime = currentTime;
  __currentTime_isset = YES;
}

- (BOOL) currentTimeIsSet {
  return __currentTime_isset;
}

- (void) unsetCurrentTime {
  __currentTime_isset = NO;
}

- (int64_t) fullSyncBefore {
  return __fullSyncBefore;
}

- (void) setFullSyncBefore: (int64_t) fullSyncBefore {
  __fullSyncBefore = fullSyncBefore;
  __fullSyncBefore_isset = YES;
}

- (BOOL) fullSyncBeforeIsSet {
  return __fullSyncBefore_isset;
}

- (void) unsetFullSyncBefore {
  __fullSyncBefore_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (int64_t) uploaded {
  return __uploaded;
}

- (void) setUploaded: (int64_t) uploaded {
  __uploaded = uploaded;
  __uploaded_isset = YES;
}

- (BOOL) uploadedIsSet {
  return __uploaded_isset;
}

- (void) unsetUploaded {
  __uploaded_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCurrentTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setFullSyncBefore: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUploaded: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncState"];
  if (__currentTime_isset) {
    [outProtocol writeFieldBeginWithName: @"currentTime" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __currentTime];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncBefore_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncBefore" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __fullSyncBefore];
    [outProtocol writeFieldEnd];
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  if (__uploaded_isset) {
    [outProtocol writeFieldBeginWithName: @"uploaded" type: TType_I64 fieldID: 4];
    [outProtocol writeI64: __uploaded];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncState("];
  [ms appendString: @"currentTime:"];
  [ms appendFormat: @"%qi", __currentTime];
  [ms appendString: @",fullSyncBefore:"];
  [ms appendFormat: @"%qi", __fullSyncBefore];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @",uploaded:"];
  [ms appendFormat: @"%qi", __uploaded];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMSyncChunk

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithCurrentTime: (EDAMTimestamp) currentTime chunkHighUSN: (int32_t) chunkHighUSN updateCount: (int32_t) updateCount notes: (NSMutableArray *) notes notebooks: (NSMutableArray *) notebooks tags: (NSMutableArray *) tags searches: (NSMutableArray *) searches resources: (NSMutableArray *) resources expungedNotes: (NSMutableArray *) expungedNotes expungedNotebooks: (NSMutableArray *) expungedNotebooks expungedTags: (NSMutableArray *) expungedTags expungedSearches: (NSMutableArray *) expungedSearches linkedNotebooks: (NSMutableArray *) linkedNotebooks expungedLinkedNotebooks: (NSMutableArray *) expungedLinkedNotebooks
{
  self = [super init];
  __currentTime = currentTime;
  __currentTime_isset = YES;
  __chunkHighUSN = chunkHighUSN;
  __chunkHighUSN_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  __notes = [notes retain_stub];
  __notes_isset = YES;
  __notebooks = [notebooks retain_stub];
  __notebooks_isset = YES;
  __tags = [tags retain_stub];
  __tags_isset = YES;
  __searches = [searches retain_stub];
  __searches_isset = YES;
  __resources = [resources retain_stub];
  __resources_isset = YES;
  __expungedNotes = [expungedNotes retain_stub];
  __expungedNotes_isset = YES;
  __expungedNotebooks = [expungedNotebooks retain_stub];
  __expungedNotebooks_isset = YES;
  __expungedTags = [expungedTags retain_stub];
  __expungedTags_isset = YES;
  __expungedSearches = [expungedSearches retain_stub];
  __expungedSearches_isset = YES;
  __linkedNotebooks = [linkedNotebooks retain_stub];
  __linkedNotebooks_isset = YES;
  __expungedLinkedNotebooks = [expungedLinkedNotebooks retain_stub];
  __expungedLinkedNotebooks_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"currentTime"])
  {
    __currentTime = [decoder decodeInt64ForKey: @"currentTime"];
    __currentTime_isset = YES;
  }
  if ([decoder containsValueForKey: @"chunkHighUSN"])
  {
    __chunkHighUSN = [decoder decodeInt32ForKey: @"chunkHighUSN"];
    __chunkHighUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain_stub];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebooks"])
  {
    __notebooks = [[decoder decodeObjectForKey: @"notebooks"] retain_stub];
    __notebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"tags"])
  {
    __tags = [[decoder decodeObjectForKey: @"tags"] retain_stub];
    __tags_isset = YES;
  }
  if ([decoder containsValueForKey: @"searches"])
  {
    __searches = [[decoder decodeObjectForKey: @"searches"] retain_stub];
    __searches_isset = YES;
  }
  if ([decoder containsValueForKey: @"resources"])
  {
    __resources = [[decoder decodeObjectForKey: @"resources"] retain_stub];
    __resources_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedNotes"])
  {
    __expungedNotes = [[decoder decodeObjectForKey: @"expungedNotes"] retain_stub];
    __expungedNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedNotebooks"])
  {
    __expungedNotebooks = [[decoder decodeObjectForKey: @"expungedNotebooks"] retain_stub];
    __expungedNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedTags"])
  {
    __expungedTags = [[decoder decodeObjectForKey: @"expungedTags"] retain_stub];
    __expungedTags_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedSearches"])
  {
    __expungedSearches = [[decoder decodeObjectForKey: @"expungedSearches"] retain_stub];
    __expungedSearches_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebooks"])
  {
    __linkedNotebooks = [[decoder decodeObjectForKey: @"linkedNotebooks"] retain_stub];
    __linkedNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedLinkedNotebooks"])
  {
    __expungedLinkedNotebooks = [[decoder decodeObjectForKey: @"expungedLinkedNotebooks"] retain_stub];
    __expungedLinkedNotebooks_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__currentTime_isset)
  {
    [encoder encodeInt64: __currentTime forKey: @"currentTime"];
  }
  if (__chunkHighUSN_isset)
  {
    [encoder encodeInt32: __chunkHighUSN forKey: @"chunkHighUSN"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__notebooks_isset)
  {
    [encoder encodeObject: __notebooks forKey: @"notebooks"];
  }
  if (__tags_isset)
  {
    [encoder encodeObject: __tags forKey: @"tags"];
  }
  if (__searches_isset)
  {
    [encoder encodeObject: __searches forKey: @"searches"];
  }
  if (__resources_isset)
  {
    [encoder encodeObject: __resources forKey: @"resources"];
  }
  if (__expungedNotes_isset)
  {
    [encoder encodeObject: __expungedNotes forKey: @"expungedNotes"];
  }
  if (__expungedNotebooks_isset)
  {
    [encoder encodeObject: __expungedNotebooks forKey: @"expungedNotebooks"];
  }
  if (__expungedTags_isset)
  {
    [encoder encodeObject: __expungedTags forKey: @"expungedTags"];
  }
  if (__expungedSearches_isset)
  {
    [encoder encodeObject: __expungedSearches forKey: @"expungedSearches"];
  }
  if (__linkedNotebooks_isset)
  {
    [encoder encodeObject: __linkedNotebooks forKey: @"linkedNotebooks"];
  }
  if (__expungedLinkedNotebooks_isset)
  {
    [encoder encodeObject: __expungedLinkedNotebooks forKey: @"expungedLinkedNotebooks"];
  }
}

- (void) dealloc
{
  [__notes release_stub];
  [__notebooks release_stub];
  [__tags release_stub];
  [__searches release_stub];
  [__resources release_stub];
  [__expungedNotes release_stub];
  [__expungedNotebooks release_stub];
  [__expungedTags release_stub];
  [__expungedSearches release_stub];
  [__linkedNotebooks release_stub];
  [__expungedLinkedNotebooks release_stub];
  [super dealloc_stub];
}

- (int64_t) currentTime {
  return __currentTime;
}

- (void) setCurrentTime: (int64_t) currentTime {
  __currentTime = currentTime;
  __currentTime_isset = YES;
}

- (BOOL) currentTimeIsSet {
  return __currentTime_isset;
}

- (void) unsetCurrentTime {
  __currentTime_isset = NO;
}

- (int32_t) chunkHighUSN {
  return __chunkHighUSN;
}

- (void) setChunkHighUSN: (int32_t) chunkHighUSN {
  __chunkHighUSN = chunkHighUSN;
  __chunkHighUSN_isset = YES;
}

- (BOOL) chunkHighUSNIsSet {
  return __chunkHighUSN_isset;
}

- (void) unsetChunkHighUSN {
  __chunkHighUSN_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (NSMutableArray *) notes {
  return [[__notes retain_stub] autorelease_stub];
}

- (void) setNotes: (NSMutableArray *) notes {
  [notes retain_stub];
  [__notes release_stub];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release_stub];
  __notes = nil;
  __notes_isset = NO;
}

- (NSMutableArray *) notebooks {
  return [[__notebooks retain_stub] autorelease_stub];
}

- (void) setNotebooks: (NSMutableArray *) notebooks {
  [notebooks retain_stub];
  [__notebooks release_stub];
  __notebooks = notebooks;
  __notebooks_isset = YES;
}

- (BOOL) notebooksIsSet {
  return __notebooks_isset;
}

- (void) unsetNotebooks {
  [__notebooks release_stub];
  __notebooks = nil;
  __notebooks_isset = NO;
}

- (NSMutableArray *) tags {
  return [[__tags retain_stub] autorelease_stub];
}

- (void) setTags: (NSMutableArray *) tags {
  [tags retain_stub];
  [__tags release_stub];
  __tags = tags;
  __tags_isset = YES;
}

- (BOOL) tagsIsSet {
  return __tags_isset;
}

- (void) unsetTags {
  [__tags release_stub];
  __tags = nil;
  __tags_isset = NO;
}

- (NSMutableArray *) searches {
  return [[__searches retain_stub] autorelease_stub];
}

- (void) setSearches: (NSMutableArray *) searches {
  [searches retain_stub];
  [__searches release_stub];
  __searches = searches;
  __searches_isset = YES;
}

- (BOOL) searchesIsSet {
  return __searches_isset;
}

- (void) unsetSearches {
  [__searches release_stub];
  __searches = nil;
  __searches_isset = NO;
}

- (NSMutableArray *) resources {
  return [[__resources retain_stub] autorelease_stub];
}

- (void) setResources: (NSMutableArray *) resources {
  [resources retain_stub];
  [__resources release_stub];
  __resources = resources;
  __resources_isset = YES;
}

- (BOOL) resourcesIsSet {
  return __resources_isset;
}

- (void) unsetResources {
  [__resources release_stub];
  __resources = nil;
  __resources_isset = NO;
}

- (NSMutableArray *) expungedNotes {
  return [[__expungedNotes retain_stub] autorelease_stub];
}

- (void) setExpungedNotes: (NSMutableArray *) expungedNotes {
  [expungedNotes retain_stub];
  [__expungedNotes release_stub];
  __expungedNotes = expungedNotes;
  __expungedNotes_isset = YES;
}

- (BOOL) expungedNotesIsSet {
  return __expungedNotes_isset;
}

- (void) unsetExpungedNotes {
  [__expungedNotes release_stub];
  __expungedNotes = nil;
  __expungedNotes_isset = NO;
}

- (NSMutableArray *) expungedNotebooks {
  return [[__expungedNotebooks retain_stub] autorelease_stub];
}

- (void) setExpungedNotebooks: (NSMutableArray *) expungedNotebooks {
  [expungedNotebooks retain_stub];
  [__expungedNotebooks release_stub];
  __expungedNotebooks = expungedNotebooks;
  __expungedNotebooks_isset = YES;
}

- (BOOL) expungedNotebooksIsSet {
  return __expungedNotebooks_isset;
}

- (void) unsetExpungedNotebooks {
  [__expungedNotebooks release_stub];
  __expungedNotebooks = nil;
  __expungedNotebooks_isset = NO;
}

- (NSMutableArray *) expungedTags {
  return [[__expungedTags retain_stub] autorelease_stub];
}

- (void) setExpungedTags: (NSMutableArray *) expungedTags {
  [expungedTags retain_stub];
  [__expungedTags release_stub];
  __expungedTags = expungedTags;
  __expungedTags_isset = YES;
}

- (BOOL) expungedTagsIsSet {
  return __expungedTags_isset;
}

- (void) unsetExpungedTags {
  [__expungedTags release_stub];
  __expungedTags = nil;
  __expungedTags_isset = NO;
}

- (NSMutableArray *) expungedSearches {
  return [[__expungedSearches retain_stub] autorelease_stub];
}

- (void) setExpungedSearches: (NSMutableArray *) expungedSearches {
  [expungedSearches retain_stub];
  [__expungedSearches release_stub];
  __expungedSearches = expungedSearches;
  __expungedSearches_isset = YES;
}

- (BOOL) expungedSearchesIsSet {
  return __expungedSearches_isset;
}

- (void) unsetExpungedSearches {
  [__expungedSearches release_stub];
  __expungedSearches = nil;
  __expungedSearches_isset = NO;
}

- (NSMutableArray *) linkedNotebooks {
  return [[__linkedNotebooks retain_stub] autorelease_stub];
}

- (void) setLinkedNotebooks: (NSMutableArray *) linkedNotebooks {
  [linkedNotebooks retain_stub];
  [__linkedNotebooks release_stub];
  __linkedNotebooks = linkedNotebooks;
  __linkedNotebooks_isset = YES;
}

- (BOOL) linkedNotebooksIsSet {
  return __linkedNotebooks_isset;
}

- (void) unsetLinkedNotebooks {
  [__linkedNotebooks release_stub];
  __linkedNotebooks = nil;
  __linkedNotebooks_isset = NO;
}

- (NSMutableArray *) expungedLinkedNotebooks {
  return [[__expungedLinkedNotebooks retain_stub] autorelease_stub];
}

- (void) setExpungedLinkedNotebooks: (NSMutableArray *) expungedLinkedNotebooks {
  [expungedLinkedNotebooks retain_stub];
  [__expungedLinkedNotebooks release_stub];
  __expungedLinkedNotebooks = expungedLinkedNotebooks;
  __expungedLinkedNotebooks_isset = YES;
}

- (BOOL) expungedLinkedNotebooksIsSet {
  return __expungedLinkedNotebooks_isset;
}

- (void) unsetExpungedLinkedNotebooks {
  [__expungedLinkedNotebooks release_stub];
  __expungedLinkedNotebooks = nil;
  __expungedLinkedNotebooks_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCurrentTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setChunkHighUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            EDAMNote *_elem2 = [[EDAMNote alloc] init];
            [_elem2 read: inProtocol];
            [fieldValue addObject: _elem2];
            [_elem2 release_stub];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size3;
          [inProtocol readListBeginReturningElementType: NULL size: &_size3];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size3];
          int _i4;
          for (_i4 = 0; _i4 < _size3; ++_i4)
          {
            EDAMNotebook *_elem5 = [[EDAMNotebook alloc] init];
            [_elem5 read: inProtocol];
            [fieldValue addObject: _elem5];
            [_elem5 release_stub];
          }
          [inProtocol readListEnd];
          [self setNotebooks: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_LIST) {
          int _size6;
          [inProtocol readListBeginReturningElementType: NULL size: &_size6];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size6];
          int _i7;
          for (_i7 = 0; _i7 < _size6; ++_i7)
          {
            EDAMTag *_elem8 = [[EDAMTag alloc] init];
            [_elem8 read: inProtocol];
            [fieldValue addObject: _elem8];
            [_elem8 release_stub];
          }
          [inProtocol readListEnd];
          [self setTags: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_LIST) {
          int _size9;
          [inProtocol readListBeginReturningElementType: NULL size: &_size9];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size9];
          int _i10;
          for (_i10 = 0; _i10 < _size9; ++_i10)
          {
            EDAMSavedSearch *_elem11 = [[EDAMSavedSearch alloc] init];
            [_elem11 read: inProtocol];
            [fieldValue addObject: _elem11];
            [_elem11 release_stub];
          }
          [inProtocol readListEnd];
          [self setSearches: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_LIST) {
          int _size12;
          [inProtocol readListBeginReturningElementType: NULL size: &_size12];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size12];
          int _i13;
          for (_i13 = 0; _i13 < _size12; ++_i13)
          {
            EDAMResource *_elem14 = [[EDAMResource alloc] init];
            [_elem14 read: inProtocol];
            [fieldValue addObject: _elem14];
            [_elem14 release_stub];
          }
          [inProtocol readListEnd];
          [self setResources: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_LIST) {
          int _size15;
          [inProtocol readListBeginReturningElementType: NULL size: &_size15];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size15];
          int _i16;
          for (_i16 = 0; _i16 < _size15; ++_i16)
          {
            NSString * _elem17 = [inProtocol readString];
            [fieldValue addObject: _elem17];
          }
          [inProtocol readListEnd];
          [self setExpungedNotes: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_LIST) {
          int _size18;
          [inProtocol readListBeginReturningElementType: NULL size: &_size18];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size18];
          int _i19;
          for (_i19 = 0; _i19 < _size18; ++_i19)
          {
            NSString * _elem20 = [inProtocol readString];
            [fieldValue addObject: _elem20];
          }
          [inProtocol readListEnd];
          [self setExpungedNotebooks: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_LIST) {
          int _size21;
          [inProtocol readListBeginReturningElementType: NULL size: &_size21];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size21];
          int _i22;
          for (_i22 = 0; _i22 < _size21; ++_i22)
          {
            NSString * _elem23 = [inProtocol readString];
            [fieldValue addObject: _elem23];
          }
          [inProtocol readListEnd];
          [self setExpungedTags: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_LIST) {
          int _size24;
          [inProtocol readListBeginReturningElementType: NULL size: &_size24];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size24];
          int _i25;
          for (_i25 = 0; _i25 < _size24; ++_i25)
          {
            NSString * _elem26 = [inProtocol readString];
            [fieldValue addObject: _elem26];
          }
          [inProtocol readListEnd];
          [self setExpungedSearches: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 13:
        if (fieldType == TType_LIST) {
          int _size27;
          [inProtocol readListBeginReturningElementType: NULL size: &_size27];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size27];
          int _i28;
          for (_i28 = 0; _i28 < _size27; ++_i28)
          {
            EDAMLinkedNotebook *_elem29 = [[EDAMLinkedNotebook alloc] init];
            [_elem29 read: inProtocol];
            [fieldValue addObject: _elem29];
            [_elem29 release_stub];
          }
          [inProtocol readListEnd];
          [self setLinkedNotebooks: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_LIST) {
          int _size30;
          [inProtocol readListBeginReturningElementType: NULL size: &_size30];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size30];
          int _i31;
          for (_i31 = 0; _i31 < _size30; ++_i31)
          {
            NSString * _elem32 = [inProtocol readString];
            [fieldValue addObject: _elem32];
          }
          [inProtocol readListEnd];
          [self setExpungedLinkedNotebooks: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncChunk"];
  if (__currentTime_isset) {
    [outProtocol writeFieldBeginWithName: @"currentTime" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __currentTime];
    [outProtocol writeFieldEnd];
  }
  if (__chunkHighUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"chunkHighUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __chunkHighUSN];
    [outProtocol writeFieldEnd];
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        int i34;
        for (i34 = 0; i34 < [__notes count]; i34++)
        {
          [[__notes objectAtIndex: i34] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebooks_isset) {
    if (__notebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"notebooks" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notebooks count]];
        int i36;
        for (i36 = 0; i36 < [__notebooks count]; i36++)
        {
          [[__notebooks objectAtIndex: i36] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__tags_isset) {
    if (__tags != nil) {
      [outProtocol writeFieldBeginWithName: @"tags" type: TType_LIST fieldID: 6];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__tags count]];
        int i38;
        for (i38 = 0; i38 < [__tags count]; i38++)
        {
          [[__tags objectAtIndex: i38] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searches_isset) {
    if (__searches != nil) {
      [outProtocol writeFieldBeginWithName: @"searches" type: TType_LIST fieldID: 7];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__searches count]];
        int i40;
        for (i40 = 0; i40 < [__searches count]; i40++)
        {
          [[__searches objectAtIndex: i40] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__resources_isset) {
    if (__resources != nil) {
      [outProtocol writeFieldBeginWithName: @"resources" type: TType_LIST fieldID: 8];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__resources count]];
        int i42;
        for (i42 = 0; i42 < [__resources count]; i42++)
        {
          [[__resources objectAtIndex: i42] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedNotes_isset) {
    if (__expungedNotes != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedNotes" type: TType_LIST fieldID: 9];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedNotes count]];
        int i44;
        for (i44 = 0; i44 < [__expungedNotes count]; i44++)
        {
          [outProtocol writeString: [__expungedNotes objectAtIndex: i44]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedNotebooks_isset) {
    if (__expungedNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedNotebooks" type: TType_LIST fieldID: 10];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedNotebooks count]];
        int i46;
        for (i46 = 0; i46 < [__expungedNotebooks count]; i46++)
        {
          [outProtocol writeString: [__expungedNotebooks objectAtIndex: i46]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedTags_isset) {
    if (__expungedTags != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedTags" type: TType_LIST fieldID: 11];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedTags count]];
        int i48;
        for (i48 = 0; i48 < [__expungedTags count]; i48++)
        {
          [outProtocol writeString: [__expungedTags objectAtIndex: i48]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedSearches_isset) {
    if (__expungedSearches != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedSearches" type: TType_LIST fieldID: 12];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedSearches count]];
        int i50;
        for (i50 = 0; i50 < [__expungedSearches count]; i50++)
        {
          [outProtocol writeString: [__expungedSearches objectAtIndex: i50]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebooks_isset) {
    if (__linkedNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebooks" type: TType_LIST fieldID: 13];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__linkedNotebooks count]];
        int i52;
        for (i52 = 0; i52 < [__linkedNotebooks count]; i52++)
        {
          [[__linkedNotebooks objectAtIndex: i52] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedLinkedNotebooks_isset) {
    if (__expungedLinkedNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedLinkedNotebooks" type: TType_LIST fieldID: 14];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedLinkedNotebooks count]];
        int i54;
        for (i54 = 0; i54 < [__expungedLinkedNotebooks count]; i54++)
        {
          [outProtocol writeString: [__expungedLinkedNotebooks objectAtIndex: i54]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncChunk("];
  [ms appendString: @"currentTime:"];
  [ms appendFormat: @"%qi", __currentTime];
  [ms appendString: @",chunkHighUSN:"];
  [ms appendFormat: @"%i", __chunkHighUSN];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",notebooks:"];
  [ms appendFormat: @"%@", __notebooks];
  [ms appendString: @",tags:"];
  [ms appendFormat: @"%@", __tags];
  [ms appendString: @",searches:"];
  [ms appendFormat: @"%@", __searches];
  [ms appendString: @",resources:"];
  [ms appendFormat: @"%@", __resources];
  [ms appendString: @",expungedNotes:"];
  [ms appendFormat: @"%@", __expungedNotes];
  [ms appendString: @",expungedNotebooks:"];
  [ms appendFormat: @"%@", __expungedNotebooks];
  [ms appendString: @",expungedTags:"];
  [ms appendFormat: @"%@", __expungedTags];
  [ms appendString: @",expungedSearches:"];
  [ms appendFormat: @"%@", __expungedSearches];
  [ms appendString: @",linkedNotebooks:"];
  [ms appendFormat: @"%@", __linkedNotebooks];
  [ms appendString: @",expungedLinkedNotebooks:"];
  [ms appendFormat: @"%@", __expungedLinkedNotebooks];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMSyncChunkFilter

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithIncludeNotes: (BOOL) includeNotes includeNoteResources: (BOOL) includeNoteResources includeNoteAttributes: (BOOL) includeNoteAttributes includeNotebooks: (BOOL) includeNotebooks includeTags: (BOOL) includeTags includeSearches: (BOOL) includeSearches includeResources: (BOOL) includeResources includeLinkedNotebooks: (BOOL) includeLinkedNotebooks includeExpunged: (BOOL) includeExpunged includeNoteApplicationDataFullMap: (BOOL) includeNoteApplicationDataFullMap includeResourceApplicationDataFullMap: (BOOL) includeResourceApplicationDataFullMap includeNoteResourceApplicationDataFullMap: (BOOL) includeNoteResourceApplicationDataFullMap requireNoteContentClass: (NSString *) requireNoteContentClass
{
  self = [super init];
  __includeNotes = includeNotes;
  __includeNotes_isset = YES;
  __includeNoteResources = includeNoteResources;
  __includeNoteResources_isset = YES;
  __includeNoteAttributes = includeNoteAttributes;
  __includeNoteAttributes_isset = YES;
  __includeNotebooks = includeNotebooks;
  __includeNotebooks_isset = YES;
  __includeTags = includeTags;
  __includeTags_isset = YES;
  __includeSearches = includeSearches;
  __includeSearches_isset = YES;
  __includeResources = includeResources;
  __includeResources_isset = YES;
  __includeLinkedNotebooks = includeLinkedNotebooks;
  __includeLinkedNotebooks_isset = YES;
  __includeExpunged = includeExpunged;
  __includeExpunged_isset = YES;
  __includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap;
  __includeNoteApplicationDataFullMap_isset = YES;
  __includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap;
  __includeResourceApplicationDataFullMap_isset = YES;
  __includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap;
  __includeNoteResourceApplicationDataFullMap_isset = YES;
  __requireNoteContentClass = [requireNoteContentClass retain_stub];
  __requireNoteContentClass_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"includeNotes"])
  {
    __includeNotes = [decoder decodeBoolForKey: @"includeNotes"];
    __includeNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteResources"])
  {
    __includeNoteResources = [decoder decodeBoolForKey: @"includeNoteResources"];
    __includeNoteResources_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteAttributes"])
  {
    __includeNoteAttributes = [decoder decodeBoolForKey: @"includeNoteAttributes"];
    __includeNoteAttributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNotebooks"])
  {
    __includeNotebooks = [decoder decodeBoolForKey: @"includeNotebooks"];
    __includeNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeTags"])
  {
    __includeTags = [decoder decodeBoolForKey: @"includeTags"];
    __includeTags_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeSearches"])
  {
    __includeSearches = [decoder decodeBoolForKey: @"includeSearches"];
    __includeSearches_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeResources"])
  {
    __includeResources = [decoder decodeBoolForKey: @"includeResources"];
    __includeResources_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeLinkedNotebooks"])
  {
    __includeLinkedNotebooks = [decoder decodeBoolForKey: @"includeLinkedNotebooks"];
    __includeLinkedNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeExpunged"])
  {
    __includeExpunged = [decoder decodeBoolForKey: @"includeExpunged"];
    __includeExpunged_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteApplicationDataFullMap"])
  {
    __includeNoteApplicationDataFullMap = [decoder decodeBoolForKey: @"includeNoteApplicationDataFullMap"];
    __includeNoteApplicationDataFullMap_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeResourceApplicationDataFullMap"])
  {
    __includeResourceApplicationDataFullMap = [decoder decodeBoolForKey: @"includeResourceApplicationDataFullMap"];
    __includeResourceApplicationDataFullMap_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteResourceApplicationDataFullMap"])
  {
    __includeNoteResourceApplicationDataFullMap = [decoder decodeBoolForKey: @"includeNoteResourceApplicationDataFullMap"];
    __includeNoteResourceApplicationDataFullMap_isset = YES;
  }
  if ([decoder containsValueForKey: @"requireNoteContentClass"])
  {
    __requireNoteContentClass = [[decoder decodeObjectForKey: @"requireNoteContentClass"] retain_stub];
    __requireNoteContentClass_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__includeNotes_isset)
  {
    [encoder encodeBool: __includeNotes forKey: @"includeNotes"];
  }
  if (__includeNoteResources_isset)
  {
    [encoder encodeBool: __includeNoteResources forKey: @"includeNoteResources"];
  }
  if (__includeNoteAttributes_isset)
  {
    [encoder encodeBool: __includeNoteAttributes forKey: @"includeNoteAttributes"];
  }
  if (__includeNotebooks_isset)
  {
    [encoder encodeBool: __includeNotebooks forKey: @"includeNotebooks"];
  }
  if (__includeTags_isset)
  {
    [encoder encodeBool: __includeTags forKey: @"includeTags"];
  }
  if (__includeSearches_isset)
  {
    [encoder encodeBool: __includeSearches forKey: @"includeSearches"];
  }
  if (__includeResources_isset)
  {
    [encoder encodeBool: __includeResources forKey: @"includeResources"];
  }
  if (__includeLinkedNotebooks_isset)
  {
    [encoder encodeBool: __includeLinkedNotebooks forKey: @"includeLinkedNotebooks"];
  }
  if (__includeExpunged_isset)
  {
    [encoder encodeBool: __includeExpunged forKey: @"includeExpunged"];
  }
  if (__includeNoteApplicationDataFullMap_isset)
  {
    [encoder encodeBool: __includeNoteApplicationDataFullMap forKey: @"includeNoteApplicationDataFullMap"];
  }
  if (__includeResourceApplicationDataFullMap_isset)
  {
    [encoder encodeBool: __includeResourceApplicationDataFullMap forKey: @"includeResourceApplicationDataFullMap"];
  }
  if (__includeNoteResourceApplicationDataFullMap_isset)
  {
    [encoder encodeBool: __includeNoteResourceApplicationDataFullMap forKey: @"includeNoteResourceApplicationDataFullMap"];
  }
  if (__requireNoteContentClass_isset)
  {
    [encoder encodeObject: __requireNoteContentClass forKey: @"requireNoteContentClass"];
  }
}

- (void) dealloc
{
  [__requireNoteContentClass release_stub];
  [super dealloc_stub];
}

- (BOOL) includeNotes {
  return __includeNotes;
}

- (void) setIncludeNotes: (BOOL) includeNotes {
  __includeNotes = includeNotes;
  __includeNotes_isset = YES;
}

- (BOOL) includeNotesIsSet {
  return __includeNotes_isset;
}

- (void) unsetIncludeNotes {
  __includeNotes_isset = NO;
}

- (BOOL) includeNoteResources {
  return __includeNoteResources;
}

- (void) setIncludeNoteResources: (BOOL) includeNoteResources {
  __includeNoteResources = includeNoteResources;
  __includeNoteResources_isset = YES;
}

- (BOOL) includeNoteResourcesIsSet {
  return __includeNoteResources_isset;
}

- (void) unsetIncludeNoteResources {
  __includeNoteResources_isset = NO;
}

- (BOOL) includeNoteAttributes {
  return __includeNoteAttributes;
}

- (void) setIncludeNoteAttributes: (BOOL) includeNoteAttributes {
  __includeNoteAttributes = includeNoteAttributes;
  __includeNoteAttributes_isset = YES;
}

- (BOOL) includeNoteAttributesIsSet {
  return __includeNoteAttributes_isset;
}

- (void) unsetIncludeNoteAttributes {
  __includeNoteAttributes_isset = NO;
}

- (BOOL) includeNotebooks {
  return __includeNotebooks;
}

- (void) setIncludeNotebooks: (BOOL) includeNotebooks {
  __includeNotebooks = includeNotebooks;
  __includeNotebooks_isset = YES;
}

- (BOOL) includeNotebooksIsSet {
  return __includeNotebooks_isset;
}

- (void) unsetIncludeNotebooks {
  __includeNotebooks_isset = NO;
}

- (BOOL) includeTags {
  return __includeTags;
}

- (void) setIncludeTags: (BOOL) includeTags {
  __includeTags = includeTags;
  __includeTags_isset = YES;
}

- (BOOL) includeTagsIsSet {
  return __includeTags_isset;
}

- (void) unsetIncludeTags {
  __includeTags_isset = NO;
}

- (BOOL) includeSearches {
  return __includeSearches;
}

- (void) setIncludeSearches: (BOOL) includeSearches {
  __includeSearches = includeSearches;
  __includeSearches_isset = YES;
}

- (BOOL) includeSearchesIsSet {
  return __includeSearches_isset;
}

- (void) unsetIncludeSearches {
  __includeSearches_isset = NO;
}

- (BOOL) includeResources {
  return __includeResources;
}

- (void) setIncludeResources: (BOOL) includeResources {
  __includeResources = includeResources;
  __includeResources_isset = YES;
}

- (BOOL) includeResourcesIsSet {
  return __includeResources_isset;
}

- (void) unsetIncludeResources {
  __includeResources_isset = NO;
}

- (BOOL) includeLinkedNotebooks {
  return __includeLinkedNotebooks;
}

- (void) setIncludeLinkedNotebooks: (BOOL) includeLinkedNotebooks {
  __includeLinkedNotebooks = includeLinkedNotebooks;
  __includeLinkedNotebooks_isset = YES;
}

- (BOOL) includeLinkedNotebooksIsSet {
  return __includeLinkedNotebooks_isset;
}

- (void) unsetIncludeLinkedNotebooks {
  __includeLinkedNotebooks_isset = NO;
}

- (BOOL) includeExpunged {
  return __includeExpunged;
}

- (void) setIncludeExpunged: (BOOL) includeExpunged {
  __includeExpunged = includeExpunged;
  __includeExpunged_isset = YES;
}

- (BOOL) includeExpungedIsSet {
  return __includeExpunged_isset;
}

- (void) unsetIncludeExpunged {
  __includeExpunged_isset = NO;
}

- (BOOL) includeNoteApplicationDataFullMap {
  return __includeNoteApplicationDataFullMap;
}

- (void) setIncludeNoteApplicationDataFullMap: (BOOL) includeNoteApplicationDataFullMap {
  __includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap;
  __includeNoteApplicationDataFullMap_isset = YES;
}

- (BOOL) includeNoteApplicationDataFullMapIsSet {
  return __includeNoteApplicationDataFullMap_isset;
}

- (void) unsetIncludeNoteApplicationDataFullMap {
  __includeNoteApplicationDataFullMap_isset = NO;
}

- (BOOL) includeResourceApplicationDataFullMap {
  return __includeResourceApplicationDataFullMap;
}

- (void) setIncludeResourceApplicationDataFullMap: (BOOL) includeResourceApplicationDataFullMap {
  __includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap;
  __includeResourceApplicationDataFullMap_isset = YES;
}

- (BOOL) includeResourceApplicationDataFullMapIsSet {
  return __includeResourceApplicationDataFullMap_isset;
}

- (void) unsetIncludeResourceApplicationDataFullMap {
  __includeResourceApplicationDataFullMap_isset = NO;
}

- (BOOL) includeNoteResourceApplicationDataFullMap {
  return __includeNoteResourceApplicationDataFullMap;
}

- (void) setIncludeNoteResourceApplicationDataFullMap: (BOOL) includeNoteResourceApplicationDataFullMap {
  __includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap;
  __includeNoteResourceApplicationDataFullMap_isset = YES;
}

- (BOOL) includeNoteResourceApplicationDataFullMapIsSet {
  return __includeNoteResourceApplicationDataFullMap_isset;
}

- (void) unsetIncludeNoteResourceApplicationDataFullMap {
  __includeNoteResourceApplicationDataFullMap_isset = NO;
}

- (NSString *) requireNoteContentClass {
  return [[__requireNoteContentClass retain_stub] autorelease_stub];
}

- (void) setRequireNoteContentClass: (NSString *) requireNoteContentClass {
  [requireNoteContentClass retain_stub];
  [__requireNoteContentClass release_stub];
  __requireNoteContentClass = requireNoteContentClass;
  __requireNoteContentClass_isset = YES;
}

- (BOOL) requireNoteContentClassIsSet {
  return __requireNoteContentClass_isset;
}

- (void) unsetRequireNoteContentClass {
  [__requireNoteContentClass release_stub];
  __requireNoteContentClass = nil;
  __requireNoteContentClass_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteResources: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteAttributes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNotebooks: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeTags: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeSearches: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeResources: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeLinkedNotebooks: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeExpunged: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteApplicationDataFullMap: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeResourceApplicationDataFullMap: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 13:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteResourceApplicationDataFullMap: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setRequireNoteContentClass: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncChunkFilter"];
  if (__includeNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNotes" type: TType_BOOL fieldID: 1];
    [outProtocol writeBool: __includeNotes];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteResources_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteResources" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeNoteResources];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteAttributes_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteAttributes" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __includeNoteAttributes];
    [outProtocol writeFieldEnd];
  }
  if (__includeNotebooks_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNotebooks" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __includeNotebooks];
    [outProtocol writeFieldEnd];
  }
  if (__includeTags_isset) {
    [outProtocol writeFieldBeginWithName: @"includeTags" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __includeTags];
    [outProtocol writeFieldEnd];
  }
  if (__includeSearches_isset) {
    [outProtocol writeFieldBeginWithName: @"includeSearches" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __includeSearches];
    [outProtocol writeFieldEnd];
  }
  if (__includeResources_isset) {
    [outProtocol writeFieldBeginWithName: @"includeResources" type: TType_BOOL fieldID: 7];
    [outProtocol writeBool: __includeResources];
    [outProtocol writeFieldEnd];
  }
  if (__includeLinkedNotebooks_isset) {
    [outProtocol writeFieldBeginWithName: @"includeLinkedNotebooks" type: TType_BOOL fieldID: 8];
    [outProtocol writeBool: __includeLinkedNotebooks];
    [outProtocol writeFieldEnd];
  }
  if (__includeExpunged_isset) {
    [outProtocol writeFieldBeginWithName: @"includeExpunged" type: TType_BOOL fieldID: 9];
    [outProtocol writeBool: __includeExpunged];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteApplicationDataFullMap_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteApplicationDataFullMap" type: TType_BOOL fieldID: 10];
    [outProtocol writeBool: __includeNoteApplicationDataFullMap];
    [outProtocol writeFieldEnd];
  }
  if (__includeResourceApplicationDataFullMap_isset) {
    [outProtocol writeFieldBeginWithName: @"includeResourceApplicationDataFullMap" type: TType_BOOL fieldID: 12];
    [outProtocol writeBool: __includeResourceApplicationDataFullMap];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteResourceApplicationDataFullMap_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteResourceApplicationDataFullMap" type: TType_BOOL fieldID: 13];
    [outProtocol writeBool: __includeNoteResourceApplicationDataFullMap];
    [outProtocol writeFieldEnd];
  }
  if (__requireNoteContentClass_isset) {
    if (__requireNoteContentClass != nil) {
      [outProtocol writeFieldBeginWithName: @"requireNoteContentClass" type: TType_STRING fieldID: 11];
      [outProtocol writeString: __requireNoteContentClass];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncChunkFilter("];
  [ms appendString: @"includeNotes:"];
  [ms appendFormat: @"%i", __includeNotes];
  [ms appendString: @",includeNoteResources:"];
  [ms appendFormat: @"%i", __includeNoteResources];
  [ms appendString: @",includeNoteAttributes:"];
  [ms appendFormat: @"%i", __includeNoteAttributes];
  [ms appendString: @",includeNotebooks:"];
  [ms appendFormat: @"%i", __includeNotebooks];
  [ms appendString: @",includeTags:"];
  [ms appendFormat: @"%i", __includeTags];
  [ms appendString: @",includeSearches:"];
  [ms appendFormat: @"%i", __includeSearches];
  [ms appendString: @",includeResources:"];
  [ms appendFormat: @"%i", __includeResources];
  [ms appendString: @",includeLinkedNotebooks:"];
  [ms appendFormat: @"%i", __includeLinkedNotebooks];
  [ms appendString: @",includeExpunged:"];
  [ms appendFormat: @"%i", __includeExpunged];
  [ms appendString: @",includeNoteApplicationDataFullMap:"];
  [ms appendFormat: @"%i", __includeNoteApplicationDataFullMap];
  [ms appendString: @",includeResourceApplicationDataFullMap:"];
  [ms appendFormat: @"%i", __includeResourceApplicationDataFullMap];
  [ms appendString: @",includeNoteResourceApplicationDataFullMap:"];
  [ms appendFormat: @"%i", __includeNoteResourceApplicationDataFullMap];
  [ms appendString: @",requireNoteContentClass:"];
  [ms appendFormat: @"\"%@\"", __requireNoteContentClass];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteFilter

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithOrder: (int32_t) order ascending: (BOOL) ascending words: (NSString *) words notebookGuid: (EDAMGuid) notebookGuid tagGuids: (NSMutableArray *) tagGuids timeZone: (NSString *) timeZone inactive: (BOOL) inactive emphasized: (NSString *) emphasized
{
  self = [super init];
  __order = order;
  __order_isset = YES;
  __ascending = ascending;
  __ascending_isset = YES;
  __words = [words retain_stub];
  __words_isset = YES;
  __notebookGuid = [notebookGuid retain_stub];
  __notebookGuid_isset = YES;
  __tagGuids = [tagGuids retain_stub];
  __tagGuids_isset = YES;
  __timeZone = [timeZone retain_stub];
  __timeZone_isset = YES;
  __inactive = inactive;
  __inactive_isset = YES;
  __emphasized = [emphasized retain_stub];
  __emphasized_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"order"])
  {
    __order = [decoder decodeInt32ForKey: @"order"];
    __order_isset = YES;
  }
  if ([decoder containsValueForKey: @"ascending"])
  {
    __ascending = [decoder decodeBoolForKey: @"ascending"];
    __ascending_isset = YES;
  }
  if ([decoder containsValueForKey: @"words"])
  {
    __words = [[decoder decodeObjectForKey: @"words"] retain_stub];
    __words_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain_stub];
    __notebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagGuids"])
  {
    __tagGuids = [[decoder decodeObjectForKey: @"tagGuids"] retain_stub];
    __tagGuids_isset = YES;
  }
  if ([decoder containsValueForKey: @"timeZone"])
  {
    __timeZone = [[decoder decodeObjectForKey: @"timeZone"] retain_stub];
    __timeZone_isset = YES;
  }
  if ([decoder containsValueForKey: @"inactive"])
  {
    __inactive = [decoder decodeBoolForKey: @"inactive"];
    __inactive_isset = YES;
  }
  if ([decoder containsValueForKey: @"emphasized"])
  {
    __emphasized = [[decoder decodeObjectForKey: @"emphasized"] retain_stub];
    __emphasized_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__order_isset)
  {
    [encoder encodeInt32: __order forKey: @"order"];
  }
  if (__ascending_isset)
  {
    [encoder encodeBool: __ascending forKey: @"ascending"];
  }
  if (__words_isset)
  {
    [encoder encodeObject: __words forKey: @"words"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
  if (__tagGuids_isset)
  {
    [encoder encodeObject: __tagGuids forKey: @"tagGuids"];
  }
  if (__timeZone_isset)
  {
    [encoder encodeObject: __timeZone forKey: @"timeZone"];
  }
  if (__inactive_isset)
  {
    [encoder encodeBool: __inactive forKey: @"inactive"];
  }
  if (__emphasized_isset)
  {
    [encoder encodeObject: __emphasized forKey: @"emphasized"];
  }
}

- (void) dealloc
{
  [__words release_stub];
  [__notebookGuid release_stub];
  [__tagGuids release_stub];
  [__timeZone release_stub];
  [__emphasized release_stub];
  [super dealloc_stub];
}

- (int32_t) order {
  return __order;
}

- (void) setOrder: (int32_t) order {
  __order = order;
  __order_isset = YES;
}

- (BOOL) orderIsSet {
  return __order_isset;
}

- (void) unsetOrder {
  __order_isset = NO;
}

- (BOOL) ascending {
  return __ascending;
}

- (void) setAscending: (BOOL) ascending {
  __ascending = ascending;
  __ascending_isset = YES;
}

- (BOOL) ascendingIsSet {
  return __ascending_isset;
}

- (void) unsetAscending {
  __ascending_isset = NO;
}

- (NSString *) words {
  return [[__words retain_stub] autorelease_stub];
}

- (void) setWords: (NSString *) words {
  [words retain_stub];
  [__words release_stub];
  __words = words;
  __words_isset = YES;
}

- (BOOL) wordsIsSet {
  return __words_isset;
}

- (void) unsetWords {
  [__words release_stub];
  __words = nil;
  __words_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain_stub] autorelease_stub];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain_stub];
  [__notebookGuid release_stub];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release_stub];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (NSMutableArray *) tagGuids {
  return [[__tagGuids retain_stub] autorelease_stub];
}

- (void) setTagGuids: (NSMutableArray *) tagGuids {
  [tagGuids retain_stub];
  [__tagGuids release_stub];
  __tagGuids = tagGuids;
  __tagGuids_isset = YES;
}

- (BOOL) tagGuidsIsSet {
  return __tagGuids_isset;
}

- (void) unsetTagGuids {
  [__tagGuids release_stub];
  __tagGuids = nil;
  __tagGuids_isset = NO;
}

- (NSString *) timeZone {
  return [[__timeZone retain_stub] autorelease_stub];
}

- (void) setTimeZone: (NSString *) timeZone {
  [timeZone retain_stub];
  [__timeZone release_stub];
  __timeZone = timeZone;
  __timeZone_isset = YES;
}

- (BOOL) timeZoneIsSet {
  return __timeZone_isset;
}

- (void) unsetTimeZone {
  [__timeZone release_stub];
  __timeZone = nil;
  __timeZone_isset = NO;
}

- (BOOL) inactive {
  return __inactive;
}

- (void) setInactive: (BOOL) inactive {
  __inactive = inactive;
  __inactive_isset = YES;
}

- (BOOL) inactiveIsSet {
  return __inactive_isset;
}

- (void) unsetInactive {
  __inactive_isset = NO;
}

- (NSString *) emphasized {
  return [[__emphasized retain_stub] autorelease_stub];
}

- (void) setEmphasized: (NSString *) emphasized {
  [emphasized retain_stub];
  [__emphasized release_stub];
  __emphasized = emphasized;
  __emphasized_isset = YES;
}

- (BOOL) emphasizedIsSet {
  return __emphasized_isset;
}

- (void) unsetEmphasized {
  [__emphasized release_stub];
  __emphasized = nil;
  __emphasized_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOrder: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setAscending: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setWords: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size55;
          [inProtocol readListBeginReturningElementType: NULL size: &_size55];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size55];
          int _i56;
          for (_i56 = 0; _i56 < _size55; ++_i56)
          {
            NSString * _elem57 = [inProtocol readString];
            [fieldValue addObject: _elem57];
          }
          [inProtocol readListEnd];
          [self setTagGuids: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTimeZone: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setInactive: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setEmphasized: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteFilter"];
  if (__order_isset) {
    [outProtocol writeFieldBeginWithName: @"order" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __order];
    [outProtocol writeFieldEnd];
  }
  if (__ascending_isset) {
    [outProtocol writeFieldBeginWithName: @"ascending" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __ascending];
    [outProtocol writeFieldEnd];
  }
  if (__words_isset) {
    if (__words != nil) {
      [outProtocol writeFieldBeginWithName: @"words" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __words];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagGuids_isset) {
    if (__tagGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"tagGuids" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__tagGuids count]];
        int i59;
        for (i59 = 0; i59 < [__tagGuids count]; i59++)
        {
          [outProtocol writeString: [__tagGuids objectAtIndex: i59]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__timeZone_isset) {
    if (__timeZone != nil) {
      [outProtocol writeFieldBeginWithName: @"timeZone" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __timeZone];
      [outProtocol writeFieldEnd];
    }
  }
  if (__inactive_isset) {
    [outProtocol writeFieldBeginWithName: @"inactive" type: TType_BOOL fieldID: 7];
    [outProtocol writeBool: __inactive];
    [outProtocol writeFieldEnd];
  }
  if (__emphasized_isset) {
    if (__emphasized != nil) {
      [outProtocol writeFieldBeginWithName: @"emphasized" type: TType_STRING fieldID: 8];
      [outProtocol writeString: __emphasized];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteFilter("];
  [ms appendString: @"order:"];
  [ms appendFormat: @"%i", __order];
  [ms appendString: @",ascending:"];
  [ms appendFormat: @"%i", __ascending];
  [ms appendString: @",words:"];
  [ms appendFormat: @"\"%@\"", __words];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @",tagGuids:"];
  [ms appendFormat: @"%@", __tagGuids];
  [ms appendString: @",timeZone:"];
  [ms appendFormat: @"\"%@\"", __timeZone];
  [ms appendString: @",inactive:"];
  [ms appendFormat: @"%i", __inactive];
  [ms appendString: @",emphasized:"];
  [ms appendFormat: @"\"%@\"", __emphasized];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteList

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStartIndex: (int32_t) startIndex totalNotes: (int32_t) totalNotes notes: (NSMutableArray *) notes stoppedWords: (NSMutableArray *) stoppedWords searchedWords: (NSMutableArray *) searchedWords updateCount: (int32_t) updateCount
{
  self = [super init];
  __startIndex = startIndex;
  __startIndex_isset = YES;
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
  __notes = [notes retain_stub];
  __notes_isset = YES;
  __stoppedWords = [stoppedWords retain_stub];
  __stoppedWords_isset = YES;
  __searchedWords = [searchedWords retain_stub];
  __searchedWords_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"startIndex"])
  {
    __startIndex = [decoder decodeInt32ForKey: @"startIndex"];
    __startIndex_isset = YES;
  }
  if ([decoder containsValueForKey: @"totalNotes"])
  {
    __totalNotes = [decoder decodeInt32ForKey: @"totalNotes"];
    __totalNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain_stub];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"stoppedWords"])
  {
    __stoppedWords = [[decoder decodeObjectForKey: @"stoppedWords"] retain_stub];
    __stoppedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"searchedWords"])
  {
    __searchedWords = [[decoder decodeObjectForKey: @"searchedWords"] retain_stub];
    __searchedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__startIndex_isset)
  {
    [encoder encodeInt32: __startIndex forKey: @"startIndex"];
  }
  if (__totalNotes_isset)
  {
    [encoder encodeInt32: __totalNotes forKey: @"totalNotes"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__stoppedWords_isset)
  {
    [encoder encodeObject: __stoppedWords forKey: @"stoppedWords"];
  }
  if (__searchedWords_isset)
  {
    [encoder encodeObject: __searchedWords forKey: @"searchedWords"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
}

- (void) dealloc
{
  [__notes release_stub];
  [__stoppedWords release_stub];
  [__searchedWords release_stub];
  [super dealloc_stub];
}

- (int32_t) startIndex {
  return __startIndex;
}

- (void) setStartIndex: (int32_t) startIndex {
  __startIndex = startIndex;
  __startIndex_isset = YES;
}

- (BOOL) startIndexIsSet {
  return __startIndex_isset;
}

- (void) unsetStartIndex {
  __startIndex_isset = NO;
}

- (int32_t) totalNotes {
  return __totalNotes;
}

- (void) setTotalNotes: (int32_t) totalNotes {
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
}

- (BOOL) totalNotesIsSet {
  return __totalNotes_isset;
}

- (void) unsetTotalNotes {
  __totalNotes_isset = NO;
}

- (NSMutableArray *) notes {
  return [[__notes retain_stub] autorelease_stub];
}

- (void) setNotes: (NSMutableArray *) notes {
  [notes retain_stub];
  [__notes release_stub];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release_stub];
  __notes = nil;
  __notes_isset = NO;
}

- (NSMutableArray *) stoppedWords {
  return [[__stoppedWords retain_stub] autorelease_stub];
}

- (void) setStoppedWords: (NSMutableArray *) stoppedWords {
  [stoppedWords retain_stub];
  [__stoppedWords release_stub];
  __stoppedWords = stoppedWords;
  __stoppedWords_isset = YES;
}

- (BOOL) stoppedWordsIsSet {
  return __stoppedWords_isset;
}

- (void) unsetStoppedWords {
  [__stoppedWords release_stub];
  __stoppedWords = nil;
  __stoppedWords_isset = NO;
}

- (NSMutableArray *) searchedWords {
  return [[__searchedWords retain_stub] autorelease_stub];
}

- (void) setSearchedWords: (NSMutableArray *) searchedWords {
  [searchedWords retain_stub];
  [__searchedWords release_stub];
  __searchedWords = searchedWords;
  __searchedWords_isset = YES;
}

- (BOOL) searchedWordsIsSet {
  return __searchedWords_isset;
}

- (void) unsetSearchedWords {
  [__searchedWords release_stub];
  __searchedWords = nil;
  __searchedWords_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setStartIndex: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTotalNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size60;
          [inProtocol readListBeginReturningElementType: NULL size: &_size60];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size60];
          int _i61;
          for (_i61 = 0; _i61 < _size60; ++_i61)
          {
            EDAMNote *_elem62 = [[EDAMNote alloc] init];
            [_elem62 read: inProtocol];
            [fieldValue addObject: _elem62];
            [_elem62 release_stub];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size63;
          [inProtocol readListBeginReturningElementType: NULL size: &_size63];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size63];
          int _i64;
          for (_i64 = 0; _i64 < _size63; ++_i64)
          {
            NSString * _elem65 = [inProtocol readString];
            [fieldValue addObject: _elem65];
          }
          [inProtocol readListEnd];
          [self setStoppedWords: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size66;
          [inProtocol readListBeginReturningElementType: NULL size: &_size66];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size66];
          int _i67;
          for (_i67 = 0; _i67 < _size66; ++_i67)
          {
            NSString * _elem68 = [inProtocol readString];
            [fieldValue addObject: _elem68];
          }
          [inProtocol readListEnd];
          [self setSearchedWords: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteList"];
  if (__startIndex_isset) {
    [outProtocol writeFieldBeginWithName: @"startIndex" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __startIndex];
    [outProtocol writeFieldEnd];
  }
  if (__totalNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"totalNotes" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __totalNotes];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        int i70;
        for (i70 = 0; i70 < [__notes count]; i70++)
        {
          [[__notes objectAtIndex: i70] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__stoppedWords_isset) {
    if (__stoppedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"stoppedWords" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__stoppedWords count]];
        int i72;
        for (i72 = 0; i72 < [__stoppedWords count]; i72++)
        {
          [outProtocol writeString: [__stoppedWords objectAtIndex: i72]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searchedWords_isset) {
    if (__searchedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"searchedWords" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__searchedWords count]];
        int i74;
        for (i74 = 0; i74 < [__searchedWords count]; i74++)
        {
          [outProtocol writeString: [__searchedWords objectAtIndex: i74]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 6];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteList("];
  [ms appendString: @"startIndex:"];
  [ms appendFormat: @"%i", __startIndex];
  [ms appendString: @",totalNotes:"];
  [ms appendFormat: @"%i", __totalNotes];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",stoppedWords:"];
  [ms appendFormat: @"%@", __stoppedWords];
  [ms appendString: @",searchedWords:"];
  [ms appendFormat: @"%@", __searchedWords];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteMetadata

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithGuid: (EDAMGuid) guid title: (NSString *) title contentLength: (int32_t) contentLength created: (EDAMTimestamp) created updated: (EDAMTimestamp) updated updateSequenceNum: (int32_t) updateSequenceNum notebookGuid: (NSString *) notebookGuid tagGuids: (NSMutableArray *) tagGuids attributes: (EDAMNoteAttributes *) attributes largestResourceMime: (NSString *) largestResourceMime largestResourceSize: (int32_t) largestResourceSize
{
  self = [super init];
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __title = [title retain_stub];
  __title_isset = YES;
  __contentLength = contentLength;
  __contentLength_isset = YES;
  __created = created;
  __created_isset = YES;
  __updated = updated;
  __updated_isset = YES;
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __notebookGuid = [notebookGuid retain_stub];
  __notebookGuid_isset = YES;
  __tagGuids = [tagGuids retain_stub];
  __tagGuids_isset = YES;
  __attributes = [attributes retain_stub];
  __attributes_isset = YES;
  __largestResourceMime = [largestResourceMime retain_stub];
  __largestResourceMime_isset = YES;
  __largestResourceSize = largestResourceSize;
  __largestResourceSize_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain_stub];
    __title_isset = YES;
  }
  if ([decoder containsValueForKey: @"contentLength"])
  {
    __contentLength = [decoder decodeInt32ForKey: @"contentLength"];
    __contentLength_isset = YES;
  }
  if ([decoder containsValueForKey: @"created"])
  {
    __created = [decoder decodeInt64ForKey: @"created"];
    __created_isset = YES;
  }
  if ([decoder containsValueForKey: @"updated"])
  {
    __updated = [decoder decodeInt64ForKey: @"updated"];
    __updated_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain_stub];
    __notebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagGuids"])
  {
    __tagGuids = [[decoder decodeObjectForKey: @"tagGuids"] retain_stub];
    __tagGuids_isset = YES;
  }
  if ([decoder containsValueForKey: @"attributes"])
  {
    __attributes = [[decoder decodeObjectForKey: @"attributes"] retain_stub];
    __attributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"largestResourceMime"])
  {
    __largestResourceMime = [[decoder decodeObjectForKey: @"largestResourceMime"] retain_stub];
    __largestResourceMime_isset = YES;
  }
  if ([decoder containsValueForKey: @"largestResourceSize"])
  {
    __largestResourceSize = [decoder decodeInt32ForKey: @"largestResourceSize"];
    __largestResourceSize_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
  if (__contentLength_isset)
  {
    [encoder encodeInt32: __contentLength forKey: @"contentLength"];
  }
  if (__created_isset)
  {
    [encoder encodeInt64: __created forKey: @"created"];
  }
  if (__updated_isset)
  {
    [encoder encodeInt64: __updated forKey: @"updated"];
  }
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
  if (__tagGuids_isset)
  {
    [encoder encodeObject: __tagGuids forKey: @"tagGuids"];
  }
  if (__attributes_isset)
  {
    [encoder encodeObject: __attributes forKey: @"attributes"];
  }
  if (__largestResourceMime_isset)
  {
    [encoder encodeObject: __largestResourceMime forKey: @"largestResourceMime"];
  }
  if (__largestResourceSize_isset)
  {
    [encoder encodeInt32: __largestResourceSize forKey: @"largestResourceSize"];
  }
}

- (void) dealloc
{
  [__guid release_stub];
  [__title release_stub];
  [__notebookGuid release_stub];
  [__tagGuids release_stub];
  [__attributes release_stub];
  [__largestResourceMime release_stub];
  [super dealloc_stub];
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) title {
  return [[__title retain_stub] autorelease_stub];
}

- (void) setTitle: (NSString *) title {
  [title retain_stub];
  [__title release_stub];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release_stub];
  __title = nil;
  __title_isset = NO;
}

- (int32_t) contentLength {
  return __contentLength;
}

- (void) setContentLength: (int32_t) contentLength {
  __contentLength = contentLength;
  __contentLength_isset = YES;
}

- (BOOL) contentLengthIsSet {
  return __contentLength_isset;
}

- (void) unsetContentLength {
  __contentLength_isset = NO;
}

- (int64_t) created {
  return __created;
}

- (void) setCreated: (int64_t) created {
  __created = created;
  __created_isset = YES;
}

- (BOOL) createdIsSet {
  return __created_isset;
}

- (void) unsetCreated {
  __created_isset = NO;
}

- (int64_t) updated {
  return __updated;
}

- (void) setUpdated: (int64_t) updated {
  __updated = updated;
  __updated_isset = YES;
}

- (BOOL) updatedIsSet {
  return __updated_isset;
}

- (void) unsetUpdated {
  __updated_isset = NO;
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain_stub] autorelease_stub];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain_stub];
  [__notebookGuid release_stub];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release_stub];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (NSMutableArray *) tagGuids {
  return [[__tagGuids retain_stub] autorelease_stub];
}

- (void) setTagGuids: (NSMutableArray *) tagGuids {
  [tagGuids retain_stub];
  [__tagGuids release_stub];
  __tagGuids = tagGuids;
  __tagGuids_isset = YES;
}

- (BOOL) tagGuidsIsSet {
  return __tagGuids_isset;
}

- (void) unsetTagGuids {
  [__tagGuids release_stub];
  __tagGuids = nil;
  __tagGuids_isset = NO;
}

- (EDAMNoteAttributes *) attributes {
  return [[__attributes retain_stub] autorelease_stub];
}

- (void) setAttributes: (EDAMNoteAttributes *) attributes {
  [attributes retain_stub];
  [__attributes release_stub];
  __attributes = attributes;
  __attributes_isset = YES;
}

- (BOOL) attributesIsSet {
  return __attributes_isset;
}

- (void) unsetAttributes {
  [__attributes release_stub];
  __attributes = nil;
  __attributes_isset = NO;
}

- (NSString *) largestResourceMime {
  return [[__largestResourceMime retain_stub] autorelease_stub];
}

- (void) setLargestResourceMime: (NSString *) largestResourceMime {
  [largestResourceMime retain_stub];
  [__largestResourceMime release_stub];
  __largestResourceMime = largestResourceMime;
  __largestResourceMime_isset = YES;
}

- (BOOL) largestResourceMimeIsSet {
  return __largestResourceMime_isset;
}

- (void) unsetLargestResourceMime {
  [__largestResourceMime release_stub];
  __largestResourceMime = nil;
  __largestResourceMime_isset = NO;
}

- (int32_t) largestResourceSize {
  return __largestResourceSize;
}

- (void) setLargestResourceSize: (int32_t) largestResourceSize {
  __largestResourceSize = largestResourceSize;
  __largestResourceSize_isset = YES;
}

- (BOOL) largestResourceSizeIsSet {
  return __largestResourceSize_isset;
}

- (void) unsetLargestResourceSize {
  __largestResourceSize_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setContentLength: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCreated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUpdated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_LIST) {
          int _size75;
          [inProtocol readListBeginReturningElementType: NULL size: &_size75];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size75];
          int _i76;
          for (_i76 = 0; _i76 < _size75; ++_i76)
          {
            NSString * _elem77 = [inProtocol readString];
            [fieldValue addObject: _elem77];
          }
          [inProtocol readListEnd];
          [self setTagGuids: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_STRUCT) {
          EDAMNoteAttributes *fieldValue = [[EDAMNoteAttributes alloc] init];
          [fieldValue read: inProtocol];
          [self setAttributes: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 20:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLargestResourceMime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 21:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setLargestResourceSize: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteMetadata"];
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  if (__contentLength_isset) {
    [outProtocol writeFieldBeginWithName: @"contentLength" type: TType_I32 fieldID: 5];
    [outProtocol writeI32: __contentLength];
    [outProtocol writeFieldEnd];
  }
  if (__created_isset) {
    [outProtocol writeFieldBeginWithName: @"created" type: TType_I64 fieldID: 6];
    [outProtocol writeI64: __created];
    [outProtocol writeFieldEnd];
  }
  if (__updated_isset) {
    [outProtocol writeFieldBeginWithName: @"updated" type: TType_I64 fieldID: 7];
    [outProtocol writeI64: __updated];
    [outProtocol writeFieldEnd];
  }
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 10];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 11];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagGuids_isset) {
    if (__tagGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"tagGuids" type: TType_LIST fieldID: 12];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__tagGuids count]];
        int i79;
        for (i79 = 0; i79 < [__tagGuids count]; i79++)
        {
          [outProtocol writeString: [__tagGuids objectAtIndex: i79]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__attributes_isset) {
    if (__attributes != nil) {
      [outProtocol writeFieldBeginWithName: @"attributes" type: TType_STRUCT fieldID: 14];
      [__attributes write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__largestResourceMime_isset) {
    if (__largestResourceMime != nil) {
      [outProtocol writeFieldBeginWithName: @"largestResourceMime" type: TType_STRING fieldID: 20];
      [outProtocol writeString: __largestResourceMime];
      [outProtocol writeFieldEnd];
    }
  }
  if (__largestResourceSize_isset) {
    [outProtocol writeFieldBeginWithName: @"largestResourceSize" type: TType_I32 fieldID: 21];
    [outProtocol writeI32: __largestResourceSize];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteMetadata("];
  [ms appendString: @"guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @",contentLength:"];
  [ms appendFormat: @"%i", __contentLength];
  [ms appendString: @",created:"];
  [ms appendFormat: @"%qi", __created];
  [ms appendString: @",updated:"];
  [ms appendFormat: @"%qi", __updated];
  [ms appendString: @",updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @",tagGuids:"];
  [ms appendFormat: @"%@", __tagGuids];
  [ms appendString: @",attributes:"];
  [ms appendFormat: @"%@", __attributes];
  [ms appendString: @",largestResourceMime:"];
  [ms appendFormat: @"\"%@\"", __largestResourceMime];
  [ms appendString: @",largestResourceSize:"];
  [ms appendFormat: @"%i", __largestResourceSize];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNotesMetadataList

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithStartIndex: (int32_t) startIndex totalNotes: (int32_t) totalNotes notes: (NSMutableArray *) notes stoppedWords: (NSMutableArray *) stoppedWords searchedWords: (NSMutableArray *) searchedWords updateCount: (int32_t) updateCount
{
  self = [super init];
  __startIndex = startIndex;
  __startIndex_isset = YES;
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
  __notes = [notes retain_stub];
  __notes_isset = YES;
  __stoppedWords = [stoppedWords retain_stub];
  __stoppedWords_isset = YES;
  __searchedWords = [searchedWords retain_stub];
  __searchedWords_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"startIndex"])
  {
    __startIndex = [decoder decodeInt32ForKey: @"startIndex"];
    __startIndex_isset = YES;
  }
  if ([decoder containsValueForKey: @"totalNotes"])
  {
    __totalNotes = [decoder decodeInt32ForKey: @"totalNotes"];
    __totalNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain_stub];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"stoppedWords"])
  {
    __stoppedWords = [[decoder decodeObjectForKey: @"stoppedWords"] retain_stub];
    __stoppedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"searchedWords"])
  {
    __searchedWords = [[decoder decodeObjectForKey: @"searchedWords"] retain_stub];
    __searchedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__startIndex_isset)
  {
    [encoder encodeInt32: __startIndex forKey: @"startIndex"];
  }
  if (__totalNotes_isset)
  {
    [encoder encodeInt32: __totalNotes forKey: @"totalNotes"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__stoppedWords_isset)
  {
    [encoder encodeObject: __stoppedWords forKey: @"stoppedWords"];
  }
  if (__searchedWords_isset)
  {
    [encoder encodeObject: __searchedWords forKey: @"searchedWords"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
}

- (void) dealloc
{
  [__notes release_stub];
  [__stoppedWords release_stub];
  [__searchedWords release_stub];
  [super dealloc_stub];
}

- (int32_t) startIndex {
  return __startIndex;
}

- (void) setStartIndex: (int32_t) startIndex {
  __startIndex = startIndex;
  __startIndex_isset = YES;
}

- (BOOL) startIndexIsSet {
  return __startIndex_isset;
}

- (void) unsetStartIndex {
  __startIndex_isset = NO;
}

- (int32_t) totalNotes {
  return __totalNotes;
}

- (void) setTotalNotes: (int32_t) totalNotes {
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
}

- (BOOL) totalNotesIsSet {
  return __totalNotes_isset;
}

- (void) unsetTotalNotes {
  __totalNotes_isset = NO;
}

- (NSMutableArray *) notes {
  return [[__notes retain_stub] autorelease_stub];
}

- (void) setNotes: (NSMutableArray *) notes {
  [notes retain_stub];
  [__notes release_stub];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release_stub];
  __notes = nil;
  __notes_isset = NO;
}

- (NSMutableArray *) stoppedWords {
  return [[__stoppedWords retain_stub] autorelease_stub];
}

- (void) setStoppedWords: (NSMutableArray *) stoppedWords {
  [stoppedWords retain_stub];
  [__stoppedWords release_stub];
  __stoppedWords = stoppedWords;
  __stoppedWords_isset = YES;
}

- (BOOL) stoppedWordsIsSet {
  return __stoppedWords_isset;
}

- (void) unsetStoppedWords {
  [__stoppedWords release_stub];
  __stoppedWords = nil;
  __stoppedWords_isset = NO;
}

- (NSMutableArray *) searchedWords {
  return [[__searchedWords retain_stub] autorelease_stub];
}

- (void) setSearchedWords: (NSMutableArray *) searchedWords {
  [searchedWords retain_stub];
  [__searchedWords release_stub];
  __searchedWords = searchedWords;
  __searchedWords_isset = YES;
}

- (BOOL) searchedWordsIsSet {
  return __searchedWords_isset;
}

- (void) unsetSearchedWords {
  [__searchedWords release_stub];
  __searchedWords = nil;
  __searchedWords_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setStartIndex: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTotalNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size80;
          [inProtocol readListBeginReturningElementType: NULL size: &_size80];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size80];
          int _i81;
          for (_i81 = 0; _i81 < _size80; ++_i81)
          {
            EDAMNoteMetadata *_elem82 = [[EDAMNoteMetadata alloc] init];
            [_elem82 read: inProtocol];
            [fieldValue addObject: _elem82];
            [_elem82 release_stub];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size83;
          [inProtocol readListBeginReturningElementType: NULL size: &_size83];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size83];
          int _i84;
          for (_i84 = 0; _i84 < _size83; ++_i84)
          {
            NSString * _elem85 = [inProtocol readString];
            [fieldValue addObject: _elem85];
          }
          [inProtocol readListEnd];
          [self setStoppedWords: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size86;
          [inProtocol readListBeginReturningElementType: NULL size: &_size86];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size86];
          int _i87;
          for (_i87 = 0; _i87 < _size86; ++_i87)
          {
            NSString * _elem88 = [inProtocol readString];
            [fieldValue addObject: _elem88];
          }
          [inProtocol readListEnd];
          [self setSearchedWords: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NotesMetadataList"];
  if (__startIndex_isset) {
    [outProtocol writeFieldBeginWithName: @"startIndex" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __startIndex];
    [outProtocol writeFieldEnd];
  }
  if (__totalNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"totalNotes" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __totalNotes];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        int i90;
        for (i90 = 0; i90 < [__notes count]; i90++)
        {
          [[__notes objectAtIndex: i90] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__stoppedWords_isset) {
    if (__stoppedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"stoppedWords" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__stoppedWords count]];
        int i92;
        for (i92 = 0; i92 < [__stoppedWords count]; i92++)
        {
          [outProtocol writeString: [__stoppedWords objectAtIndex: i92]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searchedWords_isset) {
    if (__searchedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"searchedWords" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__searchedWords count]];
        int i94;
        for (i94 = 0; i94 < [__searchedWords count]; i94++)
        {
          [outProtocol writeString: [__searchedWords objectAtIndex: i94]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 6];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NotesMetadataList("];
  [ms appendString: @"startIndex:"];
  [ms appendFormat: @"%i", __startIndex];
  [ms appendString: @",totalNotes:"];
  [ms appendFormat: @"%i", __totalNotes];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",stoppedWords:"];
  [ms appendFormat: @"%@", __stoppedWords];
  [ms appendString: @",searchedWords:"];
  [ms appendFormat: @"%@", __searchedWords];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNotesMetadataResultSpec

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithIncludeTitle: (BOOL) includeTitle includeContentLength: (BOOL) includeContentLength includeCreated: (BOOL) includeCreated includeUpdated: (BOOL) includeUpdated includeUpdateSequenceNum: (BOOL) includeUpdateSequenceNum includeNotebookGuid: (BOOL) includeNotebookGuid includeTagGuids: (BOOL) includeTagGuids includeAttributes: (BOOL) includeAttributes includeLargestResourceMime: (BOOL) includeLargestResourceMime includeLargestResourceSize: (BOOL) includeLargestResourceSize
{
  self = [super init];
  __includeTitle = includeTitle;
  __includeTitle_isset = YES;
  __includeContentLength = includeContentLength;
  __includeContentLength_isset = YES;
  __includeCreated = includeCreated;
  __includeCreated_isset = YES;
  __includeUpdated = includeUpdated;
  __includeUpdated_isset = YES;
  __includeUpdateSequenceNum = includeUpdateSequenceNum;
  __includeUpdateSequenceNum_isset = YES;
  __includeNotebookGuid = includeNotebookGuid;
  __includeNotebookGuid_isset = YES;
  __includeTagGuids = includeTagGuids;
  __includeTagGuids_isset = YES;
  __includeAttributes = includeAttributes;
  __includeAttributes_isset = YES;
  __includeLargestResourceMime = includeLargestResourceMime;
  __includeLargestResourceMime_isset = YES;
  __includeLargestResourceSize = includeLargestResourceSize;
  __includeLargestResourceSize_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"includeTitle"])
  {
    __includeTitle = [decoder decodeBoolForKey: @"includeTitle"];
    __includeTitle_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeContentLength"])
  {
    __includeContentLength = [decoder decodeBoolForKey: @"includeContentLength"];
    __includeContentLength_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeCreated"])
  {
    __includeCreated = [decoder decodeBoolForKey: @"includeCreated"];
    __includeCreated_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeUpdated"])
  {
    __includeUpdated = [decoder decodeBoolForKey: @"includeUpdated"];
    __includeUpdated_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeUpdateSequenceNum"])
  {
    __includeUpdateSequenceNum = [decoder decodeBoolForKey: @"includeUpdateSequenceNum"];
    __includeUpdateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNotebookGuid"])
  {
    __includeNotebookGuid = [decoder decodeBoolForKey: @"includeNotebookGuid"];
    __includeNotebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeTagGuids"])
  {
    __includeTagGuids = [decoder decodeBoolForKey: @"includeTagGuids"];
    __includeTagGuids_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeAttributes"])
  {
    __includeAttributes = [decoder decodeBoolForKey: @"includeAttributes"];
    __includeAttributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeLargestResourceMime"])
  {
    __includeLargestResourceMime = [decoder decodeBoolForKey: @"includeLargestResourceMime"];
    __includeLargestResourceMime_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeLargestResourceSize"])
  {
    __includeLargestResourceSize = [decoder decodeBoolForKey: @"includeLargestResourceSize"];
    __includeLargestResourceSize_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__includeTitle_isset)
  {
    [encoder encodeBool: __includeTitle forKey: @"includeTitle"];
  }
  if (__includeContentLength_isset)
  {
    [encoder encodeBool: __includeContentLength forKey: @"includeContentLength"];
  }
  if (__includeCreated_isset)
  {
    [encoder encodeBool: __includeCreated forKey: @"includeCreated"];
  }
  if (__includeUpdated_isset)
  {
    [encoder encodeBool: __includeUpdated forKey: @"includeUpdated"];
  }
  if (__includeUpdateSequenceNum_isset)
  {
    [encoder encodeBool: __includeUpdateSequenceNum forKey: @"includeUpdateSequenceNum"];
  }
  if (__includeNotebookGuid_isset)
  {
    [encoder encodeBool: __includeNotebookGuid forKey: @"includeNotebookGuid"];
  }
  if (__includeTagGuids_isset)
  {
    [encoder encodeBool: __includeTagGuids forKey: @"includeTagGuids"];
  }
  if (__includeAttributes_isset)
  {
    [encoder encodeBool: __includeAttributes forKey: @"includeAttributes"];
  }
  if (__includeLargestResourceMime_isset)
  {
    [encoder encodeBool: __includeLargestResourceMime forKey: @"includeLargestResourceMime"];
  }
  if (__includeLargestResourceSize_isset)
  {
    [encoder encodeBool: __includeLargestResourceSize forKey: @"includeLargestResourceSize"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (BOOL) includeTitle {
  return __includeTitle;
}

- (void) setIncludeTitle: (BOOL) includeTitle {
  __includeTitle = includeTitle;
  __includeTitle_isset = YES;
}

- (BOOL) includeTitleIsSet {
  return __includeTitle_isset;
}

- (void) unsetIncludeTitle {
  __includeTitle_isset = NO;
}

- (BOOL) includeContentLength {
  return __includeContentLength;
}

- (void) setIncludeContentLength: (BOOL) includeContentLength {
  __includeContentLength = includeContentLength;
  __includeContentLength_isset = YES;
}

- (BOOL) includeContentLengthIsSet {
  return __includeContentLength_isset;
}

- (void) unsetIncludeContentLength {
  __includeContentLength_isset = NO;
}

- (BOOL) includeCreated {
  return __includeCreated;
}

- (void) setIncludeCreated: (BOOL) includeCreated {
  __includeCreated = includeCreated;
  __includeCreated_isset = YES;
}

- (BOOL) includeCreatedIsSet {
  return __includeCreated_isset;
}

- (void) unsetIncludeCreated {
  __includeCreated_isset = NO;
}

- (BOOL) includeUpdated {
  return __includeUpdated;
}

- (void) setIncludeUpdated: (BOOL) includeUpdated {
  __includeUpdated = includeUpdated;
  __includeUpdated_isset = YES;
}

- (BOOL) includeUpdatedIsSet {
  return __includeUpdated_isset;
}

- (void) unsetIncludeUpdated {
  __includeUpdated_isset = NO;
}

- (BOOL) includeUpdateSequenceNum {
  return __includeUpdateSequenceNum;
}

- (void) setIncludeUpdateSequenceNum: (BOOL) includeUpdateSequenceNum {
  __includeUpdateSequenceNum = includeUpdateSequenceNum;
  __includeUpdateSequenceNum_isset = YES;
}

- (BOOL) includeUpdateSequenceNumIsSet {
  return __includeUpdateSequenceNum_isset;
}

- (void) unsetIncludeUpdateSequenceNum {
  __includeUpdateSequenceNum_isset = NO;
}

- (BOOL) includeNotebookGuid {
  return __includeNotebookGuid;
}

- (void) setIncludeNotebookGuid: (BOOL) includeNotebookGuid {
  __includeNotebookGuid = includeNotebookGuid;
  __includeNotebookGuid_isset = YES;
}

- (BOOL) includeNotebookGuidIsSet {
  return __includeNotebookGuid_isset;
}

- (void) unsetIncludeNotebookGuid {
  __includeNotebookGuid_isset = NO;
}

- (BOOL) includeTagGuids {
  return __includeTagGuids;
}

- (void) setIncludeTagGuids: (BOOL) includeTagGuids {
  __includeTagGuids = includeTagGuids;
  __includeTagGuids_isset = YES;
}

- (BOOL) includeTagGuidsIsSet {
  return __includeTagGuids_isset;
}

- (void) unsetIncludeTagGuids {
  __includeTagGuids_isset = NO;
}

- (BOOL) includeAttributes {
  return __includeAttributes;
}

- (void) setIncludeAttributes: (BOOL) includeAttributes {
  __includeAttributes = includeAttributes;
  __includeAttributes_isset = YES;
}

- (BOOL) includeAttributesIsSet {
  return __includeAttributes_isset;
}

- (void) unsetIncludeAttributes {
  __includeAttributes_isset = NO;
}

- (BOOL) includeLargestResourceMime {
  return __includeLargestResourceMime;
}

- (void) setIncludeLargestResourceMime: (BOOL) includeLargestResourceMime {
  __includeLargestResourceMime = includeLargestResourceMime;
  __includeLargestResourceMime_isset = YES;
}

- (BOOL) includeLargestResourceMimeIsSet {
  return __includeLargestResourceMime_isset;
}

- (void) unsetIncludeLargestResourceMime {
  __includeLargestResourceMime_isset = NO;
}

- (BOOL) includeLargestResourceSize {
  return __includeLargestResourceSize;
}

- (void) setIncludeLargestResourceSize: (BOOL) includeLargestResourceSize {
  __includeLargestResourceSize = includeLargestResourceSize;
  __includeLargestResourceSize_isset = YES;
}

- (BOOL) includeLargestResourceSizeIsSet {
  return __includeLargestResourceSize_isset;
}

- (void) unsetIncludeLargestResourceSize {
  __includeLargestResourceSize_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeContentLength: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeCreated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeUpdated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeTagGuids: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeAttributes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 20:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeLargestResourceMime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 21:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeLargestResourceSize: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NotesMetadataResultSpec"];
  if (__includeTitle_isset) {
    [outProtocol writeFieldBeginWithName: @"includeTitle" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeTitle];
    [outProtocol writeFieldEnd];
  }
  if (__includeContentLength_isset) {
    [outProtocol writeFieldBeginWithName: @"includeContentLength" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __includeContentLength];
    [outProtocol writeFieldEnd];
  }
  if (__includeCreated_isset) {
    [outProtocol writeFieldBeginWithName: @"includeCreated" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __includeCreated];
    [outProtocol writeFieldEnd];
  }
  if (__includeUpdated_isset) {
    [outProtocol writeFieldBeginWithName: @"includeUpdated" type: TType_BOOL fieldID: 7];
    [outProtocol writeBool: __includeUpdated];
    [outProtocol writeFieldEnd];
  }
  if (__includeUpdateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"includeUpdateSequenceNum" type: TType_BOOL fieldID: 10];
    [outProtocol writeBool: __includeUpdateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__includeNotebookGuid_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNotebookGuid" type: TType_BOOL fieldID: 11];
    [outProtocol writeBool: __includeNotebookGuid];
    [outProtocol writeFieldEnd];
  }
  if (__includeTagGuids_isset) {
    [outProtocol writeFieldBeginWithName: @"includeTagGuids" type: TType_BOOL fieldID: 12];
    [outProtocol writeBool: __includeTagGuids];
    [outProtocol writeFieldEnd];
  }
  if (__includeAttributes_isset) {
    [outProtocol writeFieldBeginWithName: @"includeAttributes" type: TType_BOOL fieldID: 14];
    [outProtocol writeBool: __includeAttributes];
    [outProtocol writeFieldEnd];
  }
  if (__includeLargestResourceMime_isset) {
    [outProtocol writeFieldBeginWithName: @"includeLargestResourceMime" type: TType_BOOL fieldID: 20];
    [outProtocol writeBool: __includeLargestResourceMime];
    [outProtocol writeFieldEnd];
  }
  if (__includeLargestResourceSize_isset) {
    [outProtocol writeFieldBeginWithName: @"includeLargestResourceSize" type: TType_BOOL fieldID: 21];
    [outProtocol writeBool: __includeLargestResourceSize];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NotesMetadataResultSpec("];
  [ms appendString: @"includeTitle:"];
  [ms appendFormat: @"%i", __includeTitle];
  [ms appendString: @",includeContentLength:"];
  [ms appendFormat: @"%i", __includeContentLength];
  [ms appendString: @",includeCreated:"];
  [ms appendFormat: @"%i", __includeCreated];
  [ms appendString: @",includeUpdated:"];
  [ms appendFormat: @"%i", __includeUpdated];
  [ms appendString: @",includeUpdateSequenceNum:"];
  [ms appendFormat: @"%i", __includeUpdateSequenceNum];
  [ms appendString: @",includeNotebookGuid:"];
  [ms appendFormat: @"%i", __includeNotebookGuid];
  [ms appendString: @",includeTagGuids:"];
  [ms appendFormat: @"%i", __includeTagGuids];
  [ms appendString: @",includeAttributes:"];
  [ms appendFormat: @"%i", __includeAttributes];
  [ms appendString: @",includeLargestResourceMime:"];
  [ms appendFormat: @"%i", __includeLargestResourceMime];
  [ms appendString: @",includeLargestResourceSize:"];
  [ms appendFormat: @"%i", __includeLargestResourceSize];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteCollectionCounts

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNotebookCounts: (NSMutableDictionary *) notebookCounts tagCounts: (NSMutableDictionary *) tagCounts trashCount: (int32_t) trashCount
{
  self = [super init];
  __notebookCounts = [notebookCounts retain_stub];
  __notebookCounts_isset = YES;
  __tagCounts = [tagCounts retain_stub];
  __tagCounts_isset = YES;
  __trashCount = trashCount;
  __trashCount_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"notebookCounts"])
  {
    __notebookCounts = [[decoder decodeObjectForKey: @"notebookCounts"] retain_stub];
    __notebookCounts_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagCounts"])
  {
    __tagCounts = [[decoder decodeObjectForKey: @"tagCounts"] retain_stub];
    __tagCounts_isset = YES;
  }
  if ([decoder containsValueForKey: @"trashCount"])
  {
    __trashCount = [decoder decodeInt32ForKey: @"trashCount"];
    __trashCount_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__notebookCounts_isset)
  {
    [encoder encodeObject: __notebookCounts forKey: @"notebookCounts"];
  }
  if (__tagCounts_isset)
  {
    [encoder encodeObject: __tagCounts forKey: @"tagCounts"];
  }
  if (__trashCount_isset)
  {
    [encoder encodeInt32: __trashCount forKey: @"trashCount"];
  }
}

- (void) dealloc
{
  [__notebookCounts release_stub];
  [__tagCounts release_stub];
  [super dealloc_stub];
}

- (NSMutableDictionary *) notebookCounts {
  return [[__notebookCounts retain_stub] autorelease_stub];
}

- (void) setNotebookCounts: (NSMutableDictionary *) notebookCounts {
  [notebookCounts retain_stub];
  [__notebookCounts release_stub];
  __notebookCounts = notebookCounts;
  __notebookCounts_isset = YES;
}

- (BOOL) notebookCountsIsSet {
  return __notebookCounts_isset;
}

- (void) unsetNotebookCounts {
  [__notebookCounts release_stub];
  __notebookCounts = nil;
  __notebookCounts_isset = NO;
}

- (NSMutableDictionary *) tagCounts {
  return [[__tagCounts retain_stub] autorelease_stub];
}

- (void) setTagCounts: (NSMutableDictionary *) tagCounts {
  [tagCounts retain_stub];
  [__tagCounts release_stub];
  __tagCounts = tagCounts;
  __tagCounts_isset = YES;
}

- (BOOL) tagCountsIsSet {
  return __tagCounts_isset;
}

- (void) unsetTagCounts {
  [__tagCounts release_stub];
  __tagCounts = nil;
  __tagCounts_isset = NO;
}

- (int32_t) trashCount {
  return __trashCount;
}

- (void) setTrashCount: (int32_t) trashCount {
  __trashCount = trashCount;
  __trashCount_isset = YES;
}

- (BOOL) trashCountIsSet {
  return __trashCount_isset;
}

- (void) unsetTrashCount {
  __trashCount_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_MAP) {
          int _size95;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size95];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size95];
          int _i96;
          for (_i96 = 0; _i96 < _size95; ++_i96)
          {
            NSString * _key97 = [inProtocol readString];
            int32_t _val98 = [inProtocol readI32];
            [fieldValue setObject: [NSNumber numberWithLong: _val98] forKey: _key97];
          }
          [inProtocol readMapEnd];
          [self setNotebookCounts: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_MAP) {
          int _size99;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size99];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size99];
          int _i100;
          for (_i100 = 0; _i100 < _size99; ++_i100)
          {
            NSString * _key101 = [inProtocol readString];
            int32_t _val102 = [inProtocol readI32];
            [fieldValue setObject: [NSNumber numberWithLong: _val102] forKey: _key101];
          }
          [inProtocol readMapEnd];
          [self setTagCounts: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTrashCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteCollectionCounts"];
  if (__notebookCounts_isset) {
    if (__notebookCounts != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookCounts" type: TType_MAP fieldID: 1];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_I32 size: [__notebookCounts count]];
        NSEnumerator * _iter103 = [__notebookCounts keyEnumerator];
        id key104;
        while ((key104 = [_iter103 nextObject]))
        {
          [outProtocol writeString: key104];
          [outProtocol writeI32: [[__notebookCounts objectForKey: key104] longValue]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagCounts_isset) {
    if (__tagCounts != nil) {
      [outProtocol writeFieldBeginWithName: @"tagCounts" type: TType_MAP fieldID: 2];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_I32 size: [__tagCounts count]];
        NSEnumerator * _iter105 = [__tagCounts keyEnumerator];
        id key106;
        while ((key106 = [_iter105 nextObject]))
        {
          [outProtocol writeString: key106];
          [outProtocol writeI32: [[__tagCounts objectForKey: key106] longValue]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__trashCount_isset) {
    [outProtocol writeFieldBeginWithName: @"trashCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __trashCount];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteCollectionCounts("];
  [ms appendString: @"notebookCounts:"];
  [ms appendFormat: @"%@", __notebookCounts];
  [ms appendString: @",tagCounts:"];
  [ms appendFormat: @"%@", __tagCounts];
  [ms appendString: @",trashCount:"];
  [ms appendFormat: @"%i", __trashCount];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteEmailParameters

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithGuid: (NSString *) guid note: (EDAMNote *) note toAddresses: (NSMutableArray *) toAddresses ccAddresses: (NSMutableArray *) ccAddresses subject: (NSString *) subject message: (NSString *) message
{
  self = [super init];
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __note = [note retain_stub];
  __note_isset = YES;
  __toAddresses = [toAddresses retain_stub];
  __toAddresses_isset = YES;
  __ccAddresses = [ccAddresses retain_stub];
  __ccAddresses_isset = YES;
  __subject = [subject retain_stub];
  __subject_isset = YES;
  __message = [message retain_stub];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain_stub];
    __note_isset = YES;
  }
  if ([decoder containsValueForKey: @"toAddresses"])
  {
    __toAddresses = [[decoder decodeObjectForKey: @"toAddresses"] retain_stub];
    __toAddresses_isset = YES;
  }
  if ([decoder containsValueForKey: @"ccAddresses"])
  {
    __ccAddresses = [[decoder decodeObjectForKey: @"ccAddresses"] retain_stub];
    __ccAddresses_isset = YES;
  }
  if ([decoder containsValueForKey: @"subject"])
  {
    __subject = [[decoder decodeObjectForKey: @"subject"] retain_stub];
    __subject_isset = YES;
  }
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain_stub];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
  if (__toAddresses_isset)
  {
    [encoder encodeObject: __toAddresses forKey: @"toAddresses"];
  }
  if (__ccAddresses_isset)
  {
    [encoder encodeObject: __ccAddresses forKey: @"ccAddresses"];
  }
  if (__subject_isset)
  {
    [encoder encodeObject: __subject forKey: @"subject"];
  }
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__guid release_stub];
  [__note release_stub];
  [__toAddresses release_stub];
  [__ccAddresses release_stub];
  [__subject release_stub];
  [__message release_stub];
  [super dealloc_stub];
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain_stub] autorelease_stub];
}

- (void) setNote: (EDAMNote *) note {
  [note retain_stub];
  [__note release_stub];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release_stub];
  __note = nil;
  __note_isset = NO;
}

- (NSMutableArray *) toAddresses {
  return [[__toAddresses retain_stub] autorelease_stub];
}

- (void) setToAddresses: (NSMutableArray *) toAddresses {
  [toAddresses retain_stub];
  [__toAddresses release_stub];
  __toAddresses = toAddresses;
  __toAddresses_isset = YES;
}

- (BOOL) toAddressesIsSet {
  return __toAddresses_isset;
}

- (void) unsetToAddresses {
  [__toAddresses release_stub];
  __toAddresses = nil;
  __toAddresses_isset = NO;
}

- (NSMutableArray *) ccAddresses {
  return [[__ccAddresses retain_stub] autorelease_stub];
}

- (void) setCcAddresses: (NSMutableArray *) ccAddresses {
  [ccAddresses retain_stub];
  [__ccAddresses release_stub];
  __ccAddresses = ccAddresses;
  __ccAddresses_isset = YES;
}

- (BOOL) ccAddressesIsSet {
  return __ccAddresses_isset;
}

- (void) unsetCcAddresses {
  [__ccAddresses release_stub];
  __ccAddresses = nil;
  __ccAddresses_isset = NO;
}

- (NSString *) subject {
  return [[__subject retain_stub] autorelease_stub];
}

- (void) setSubject: (NSString *) subject {
  [subject retain_stub];
  [__subject release_stub];
  __subject = subject;
  __subject_isset = YES;
}

- (BOOL) subjectIsSet {
  return __subject_isset;
}

- (void) unsetSubject {
  [__subject release_stub];
  __subject = nil;
  __subject_isset = NO;
}

- (NSString *) message {
  return [[__message retain_stub] autorelease_stub];
}

- (void) setMessage: (NSString *) message {
  [message retain_stub];
  [__message release_stub];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release_stub];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size107;
          [inProtocol readListBeginReturningElementType: NULL size: &_size107];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size107];
          int _i108;
          for (_i108 = 0; _i108 < _size107; ++_i108)
          {
            NSString * _elem109 = [inProtocol readString];
            [fieldValue addObject: _elem109];
          }
          [inProtocol readListEnd];
          [self setToAddresses: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size110;
          [inProtocol readListBeginReturningElementType: NULL size: &_size110];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size110];
          int _i111;
          for (_i111 = 0; _i111 < _size110; ++_i111)
          {
            NSString * _elem112 = [inProtocol readString];
            [fieldValue addObject: _elem112];
          }
          [inProtocol readListEnd];
          [self setCcAddresses: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubject: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteEmailParameters"];
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__toAddresses_isset) {
    if (__toAddresses != nil) {
      [outProtocol writeFieldBeginWithName: @"toAddresses" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__toAddresses count]];
        int i114;
        for (i114 = 0; i114 < [__toAddresses count]; i114++)
        {
          [outProtocol writeString: [__toAddresses objectAtIndex: i114]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__ccAddresses_isset) {
    if (__ccAddresses != nil) {
      [outProtocol writeFieldBeginWithName: @"ccAddresses" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__ccAddresses count]];
        int i116;
        for (i116 = 0; i116 < [__ccAddresses count]; i116++)
        {
          [outProtocol writeString: [__ccAddresses objectAtIndex: i116]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__subject_isset) {
    if (__subject != nil) {
      [outProtocol writeFieldBeginWithName: @"subject" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __subject];
      [outProtocol writeFieldEnd];
    }
  }
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteEmailParameters("];
  [ms appendString: @"guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @",toAddresses:"];
  [ms appendFormat: @"%@", __toAddresses];
  [ms appendString: @",ccAddresses:"];
  [ms appendFormat: @"%@", __ccAddresses];
  [ms appendString: @",subject:"];
  [ms appendFormat: @"\"%@\"", __subject];
  [ms appendString: @",message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteVersionId

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithUpdateSequenceNum: (int32_t) updateSequenceNum updated: (EDAMTimestamp) updated saved: (EDAMTimestamp) saved title: (NSString *) title
{
  self = [super init];
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __updated = updated;
  __updated_isset = YES;
  __saved = saved;
  __saved_isset = YES;
  __title = [title retain_stub];
  __title_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"updated"])
  {
    __updated = [decoder decodeInt64ForKey: @"updated"];
    __updated_isset = YES;
  }
  if ([decoder containsValueForKey: @"saved"])
  {
    __saved = [decoder decodeInt64ForKey: @"saved"];
    __saved_isset = YES;
  }
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain_stub];
    __title_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__updated_isset)
  {
    [encoder encodeInt64: __updated forKey: @"updated"];
  }
  if (__saved_isset)
  {
    [encoder encodeInt64: __saved forKey: @"saved"];
  }
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
}

- (void) dealloc
{
  [__title release_stub];
  [super dealloc_stub];
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (int64_t) updated {
  return __updated;
}

- (void) setUpdated: (int64_t) updated {
  __updated = updated;
  __updated_isset = YES;
}

- (BOOL) updatedIsSet {
  return __updated_isset;
}

- (void) unsetUpdated {
  __updated_isset = NO;
}

- (int64_t) saved {
  return __saved;
}

- (void) setSaved: (int64_t) saved {
  __saved = saved;
  __saved_isset = YES;
}

- (BOOL) savedIsSet {
  return __saved_isset;
}

- (void) unsetSaved {
  __saved_isset = NO;
}

- (NSString *) title {
  return [[__title retain_stub] autorelease_stub];
}

- (void) setTitle: (NSString *) title {
  [title retain_stub];
  [__title release_stub];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release_stub];
  __title = nil;
  __title_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUpdated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setSaved: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteVersionId"];
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__updated_isset) {
    [outProtocol writeFieldBeginWithName: @"updated" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __updated];
    [outProtocol writeFieldEnd];
  }
  if (__saved_isset) {
    [outProtocol writeFieldBeginWithName: @"saved" type: TType_I64 fieldID: 3];
    [outProtocol writeI64: __saved];
    [outProtocol writeFieldEnd];
  }
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteVersionId("];
  [ms appendString: @"updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",updated:"];
  [ms appendFormat: @"%qi", __updated];
  [ms appendString: @",saved:"];
  [ms appendFormat: @"%qi", __saved];
  [ms appendString: @",title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMClientUsageMetrics

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSessions: (int32_t) sessions
{
  self = [super init];
  __sessions = sessions;
  __sessions_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"sessions"])
  {
    __sessions = [decoder decodeInt32ForKey: @"sessions"];
    __sessions_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__sessions_isset)
  {
    [encoder encodeInt32: __sessions forKey: @"sessions"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (int32_t) sessions {
  return __sessions;
}

- (void) setSessions: (int32_t) sessions {
  __sessions = sessions;
  __sessions_isset = YES;
}

- (BOOL) sessionsIsSet {
  return __sessions_isset;
}

- (void) unsetSessions {
  __sessions_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSessions: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ClientUsageMetrics"];
  if (__sessions_isset) {
    [outProtocol writeFieldBeginWithName: @"sessions" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __sessions];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ClientUsageMetrics("];
  [ms appendString: @"sessions:"];
  [ms appendFormat: @"%i", __sessions];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMRelatedQuery

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNoteGuid: (NSString *) noteGuid plainText: (NSString *) plainText filter: (EDAMNoteFilter *) filter
{
  self = [super init];
  __noteGuid = [noteGuid retain_stub];
  __noteGuid_isset = YES;
  __plainText = [plainText retain_stub];
  __plainText_isset = YES;
  __filter = [filter retain_stub];
  __filter_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain_stub];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"plainText"])
  {
    __plainText = [[decoder decodeObjectForKey: @"plainText"] retain_stub];
    __plainText_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain_stub];
    __filter_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__plainText_isset)
  {
    [encoder encodeObject: __plainText forKey: @"plainText"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
}

- (void) dealloc
{
  [__noteGuid release_stub];
  [__plainText release_stub];
  [__filter release_stub];
  [super dealloc_stub];
}

- (NSString *) noteGuid {
  return [[__noteGuid retain_stub] autorelease_stub];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain_stub];
  [__noteGuid release_stub];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release_stub];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (NSString *) plainText {
  return [[__plainText retain_stub] autorelease_stub];
}

- (void) setPlainText: (NSString *) plainText {
  [plainText retain_stub];
  [__plainText release_stub];
  __plainText = plainText;
  __plainText_isset = YES;
}

- (BOOL) plainTextIsSet {
  return __plainText_isset;
}

- (void) unsetPlainText {
  [__plainText release_stub];
  __plainText = nil;
  __plainText_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain_stub] autorelease_stub];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain_stub];
  [__filter release_stub];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release_stub];
  __filter = nil;
  __filter_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPlainText: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RelatedQuery"];
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__plainText_isset) {
    if (__plainText != nil) {
      [outProtocol writeFieldBeginWithName: @"plainText" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __plainText];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 3];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RelatedQuery("];
  [ms appendString: @"noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",plainText:"];
  [ms appendFormat: @"\"%@\"", __plainText];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMRelatedResult

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNotes: (NSMutableArray *) notes notebooks: (NSMutableArray *) notebooks tags: (NSMutableArray *) tags containingNotebooks: (NSMutableArray *) containingNotebooks debugInfo: (NSString *) debugInfo
{
  self = [super init];
  __notes = [notes retain_stub];
  __notes_isset = YES;
  __notebooks = [notebooks retain_stub];
  __notebooks_isset = YES;
  __tags = [tags retain_stub];
  __tags_isset = YES;
  __containingNotebooks = [containingNotebooks retain_stub];
  __containingNotebooks_isset = YES;
  __debugInfo = [debugInfo retain_stub];
  __debugInfo_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain_stub];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebooks"])
  {
    __notebooks = [[decoder decodeObjectForKey: @"notebooks"] retain_stub];
    __notebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"tags"])
  {
    __tags = [[decoder decodeObjectForKey: @"tags"] retain_stub];
    __tags_isset = YES;
  }
  if ([decoder containsValueForKey: @"containingNotebooks"])
  {
    __containingNotebooks = [[decoder decodeObjectForKey: @"containingNotebooks"] retain_stub];
    __containingNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"debugInfo"])
  {
    __debugInfo = [[decoder decodeObjectForKey: @"debugInfo"] retain_stub];
    __debugInfo_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__notebooks_isset)
  {
    [encoder encodeObject: __notebooks forKey: @"notebooks"];
  }
  if (__tags_isset)
  {
    [encoder encodeObject: __tags forKey: @"tags"];
  }
  if (__containingNotebooks_isset)
  {
    [encoder encodeObject: __containingNotebooks forKey: @"containingNotebooks"];
  }
  if (__debugInfo_isset)
  {
    [encoder encodeObject: __debugInfo forKey: @"debugInfo"];
  }
}

- (void) dealloc
{
  [__notes release_stub];
  [__notebooks release_stub];
  [__tags release_stub];
  [__containingNotebooks release_stub];
  [__debugInfo release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) notes {
  return [[__notes retain_stub] autorelease_stub];
}

- (void) setNotes: (NSMutableArray *) notes {
  [notes retain_stub];
  [__notes release_stub];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release_stub];
  __notes = nil;
  __notes_isset = NO;
}

- (NSMutableArray *) notebooks {
  return [[__notebooks retain_stub] autorelease_stub];
}

- (void) setNotebooks: (NSMutableArray *) notebooks {
  [notebooks retain_stub];
  [__notebooks release_stub];
  __notebooks = notebooks;
  __notebooks_isset = YES;
}

- (BOOL) notebooksIsSet {
  return __notebooks_isset;
}

- (void) unsetNotebooks {
  [__notebooks release_stub];
  __notebooks = nil;
  __notebooks_isset = NO;
}

- (NSMutableArray *) tags {
  return [[__tags retain_stub] autorelease_stub];
}

- (void) setTags: (NSMutableArray *) tags {
  [tags retain_stub];
  [__tags release_stub];
  __tags = tags;
  __tags_isset = YES;
}

- (BOOL) tagsIsSet {
  return __tags_isset;
}

- (void) unsetTags {
  [__tags release_stub];
  __tags = nil;
  __tags_isset = NO;
}

- (NSMutableArray *) containingNotebooks {
  return [[__containingNotebooks retain_stub] autorelease_stub];
}

- (void) setContainingNotebooks: (NSMutableArray *) containingNotebooks {
  [containingNotebooks retain_stub];
  [__containingNotebooks release_stub];
  __containingNotebooks = containingNotebooks;
  __containingNotebooks_isset = YES;
}

- (BOOL) containingNotebooksIsSet {
  return __containingNotebooks_isset;
}

- (void) unsetContainingNotebooks {
  [__containingNotebooks release_stub];
  __containingNotebooks = nil;
  __containingNotebooks_isset = NO;
}

- (NSString *) debugInfo {
  return [[__debugInfo retain_stub] autorelease_stub];
}

- (void) setDebugInfo: (NSString *) debugInfo {
  [debugInfo retain_stub];
  [__debugInfo release_stub];
  __debugInfo = debugInfo;
  __debugInfo_isset = YES;
}

- (BOOL) debugInfoIsSet {
  return __debugInfo_isset;
}

- (void) unsetDebugInfo {
  [__debugInfo release_stub];
  __debugInfo = nil;
  __debugInfo_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_LIST) {
          int _size117;
          [inProtocol readListBeginReturningElementType: NULL size: &_size117];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size117];
          int _i118;
          for (_i118 = 0; _i118 < _size117; ++_i118)
          {
            EDAMNote *_elem119 = [[EDAMNote alloc] init];
            [_elem119 read: inProtocol];
            [fieldValue addObject: _elem119];
            [_elem119 release_stub];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size120;
          [inProtocol readListBeginReturningElementType: NULL size: &_size120];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size120];
          int _i121;
          for (_i121 = 0; _i121 < _size120; ++_i121)
          {
            EDAMNotebook *_elem122 = [[EDAMNotebook alloc] init];
            [_elem122 read: inProtocol];
            [fieldValue addObject: _elem122];
            [_elem122 release_stub];
          }
          [inProtocol readListEnd];
          [self setNotebooks: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size123;
          [inProtocol readListBeginReturningElementType: NULL size: &_size123];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size123];
          int _i124;
          for (_i124 = 0; _i124 < _size123; ++_i124)
          {
            EDAMTag *_elem125 = [[EDAMTag alloc] init];
            [_elem125 read: inProtocol];
            [fieldValue addObject: _elem125];
            [_elem125 release_stub];
          }
          [inProtocol readListEnd];
          [self setTags: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size126;
          [inProtocol readListBeginReturningElementType: NULL size: &_size126];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size126];
          int _i127;
          for (_i127 = 0; _i127 < _size126; ++_i127)
          {
            EDAMNotebookDescriptor *_elem128 = [[EDAMNotebookDescriptor alloc] init];
            [_elem128 read: inProtocol];
            [fieldValue addObject: _elem128];
            [_elem128 release_stub];
          }
          [inProtocol readListEnd];
          [self setContainingNotebooks: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDebugInfo: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RelatedResult"];
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 1];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        int i130;
        for (i130 = 0; i130 < [__notes count]; i130++)
        {
          [[__notes objectAtIndex: i130] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebooks_isset) {
    if (__notebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"notebooks" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notebooks count]];
        int i132;
        for (i132 = 0; i132 < [__notebooks count]; i132++)
        {
          [[__notebooks objectAtIndex: i132] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__tags_isset) {
    if (__tags != nil) {
      [outProtocol writeFieldBeginWithName: @"tags" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__tags count]];
        int i134;
        for (i134 = 0; i134 < [__tags count]; i134++)
        {
          [[__tags objectAtIndex: i134] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__containingNotebooks_isset) {
    if (__containingNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"containingNotebooks" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__containingNotebooks count]];
        int i136;
        for (i136 = 0; i136 < [__containingNotebooks count]; i136++)
        {
          [[__containingNotebooks objectAtIndex: i136] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__debugInfo_isset) {
    if (__debugInfo != nil) {
      [outProtocol writeFieldBeginWithName: @"debugInfo" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __debugInfo];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RelatedResult("];
  [ms appendString: @"notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",notebooks:"];
  [ms appendFormat: @"%@", __notebooks];
  [ms appendString: @",tags:"];
  [ms appendFormat: @"%@", __tags];
  [ms appendString: @",containingNotebooks:"];
  [ms appendFormat: @"%@", __containingNotebooks];
  [ms appendString: @",debugInfo:"];
  [ms appendFormat: @"\"%@\"", __debugInfo];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMRelatedResultSpec

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithMaxNotes: (int32_t) maxNotes maxNotebooks: (int32_t) maxNotebooks maxTags: (int32_t) maxTags writableNotebooksOnly: (BOOL) writableNotebooksOnly includeContainingNotebooks: (BOOL) includeContainingNotebooks includeDebugInfo: (BOOL) includeDebugInfo
{
  self = [super init];
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
  __maxNotebooks = maxNotebooks;
  __maxNotebooks_isset = YES;
  __maxTags = maxTags;
  __maxTags_isset = YES;
  __writableNotebooksOnly = writableNotebooksOnly;
  __writableNotebooksOnly_isset = YES;
  __includeContainingNotebooks = includeContainingNotebooks;
  __includeContainingNotebooks_isset = YES;
  __includeDebugInfo = includeDebugInfo;
  __includeDebugInfo_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"maxNotes"])
  {
    __maxNotes = [decoder decodeInt32ForKey: @"maxNotes"];
    __maxNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxNotebooks"])
  {
    __maxNotebooks = [decoder decodeInt32ForKey: @"maxNotebooks"];
    __maxNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxTags"])
  {
    __maxTags = [decoder decodeInt32ForKey: @"maxTags"];
    __maxTags_isset = YES;
  }
  if ([decoder containsValueForKey: @"writableNotebooksOnly"])
  {
    __writableNotebooksOnly = [decoder decodeBoolForKey: @"writableNotebooksOnly"];
    __writableNotebooksOnly_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeContainingNotebooks"])
  {
    __includeContainingNotebooks = [decoder decodeBoolForKey: @"includeContainingNotebooks"];
    __includeContainingNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeDebugInfo"])
  {
    __includeDebugInfo = [decoder decodeBoolForKey: @"includeDebugInfo"];
    __includeDebugInfo_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__maxNotes_isset)
  {
    [encoder encodeInt32: __maxNotes forKey: @"maxNotes"];
  }
  if (__maxNotebooks_isset)
  {
    [encoder encodeInt32: __maxNotebooks forKey: @"maxNotebooks"];
  }
  if (__maxTags_isset)
  {
    [encoder encodeInt32: __maxTags forKey: @"maxTags"];
  }
  if (__writableNotebooksOnly_isset)
  {
    [encoder encodeBool: __writableNotebooksOnly forKey: @"writableNotebooksOnly"];
  }
  if (__includeContainingNotebooks_isset)
  {
    [encoder encodeBool: __includeContainingNotebooks forKey: @"includeContainingNotebooks"];
  }
  if (__includeDebugInfo_isset)
  {
    [encoder encodeBool: __includeDebugInfo forKey: @"includeDebugInfo"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (int32_t) maxNotes {
  return __maxNotes;
}

- (void) setMaxNotes: (int32_t) maxNotes {
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
}

- (BOOL) maxNotesIsSet {
  return __maxNotes_isset;
}

- (void) unsetMaxNotes {
  __maxNotes_isset = NO;
}

- (int32_t) maxNotebooks {
  return __maxNotebooks;
}

- (void) setMaxNotebooks: (int32_t) maxNotebooks {
  __maxNotebooks = maxNotebooks;
  __maxNotebooks_isset = YES;
}

- (BOOL) maxNotebooksIsSet {
  return __maxNotebooks_isset;
}

- (void) unsetMaxNotebooks {
  __maxNotebooks_isset = NO;
}

- (int32_t) maxTags {
  return __maxTags;
}

- (void) setMaxTags: (int32_t) maxTags {
  __maxTags = maxTags;
  __maxTags_isset = YES;
}

- (BOOL) maxTagsIsSet {
  return __maxTags_isset;
}

- (void) unsetMaxTags {
  __maxTags_isset = NO;
}

- (BOOL) writableNotebooksOnly {
  return __writableNotebooksOnly;
}

- (void) setWritableNotebooksOnly: (BOOL) writableNotebooksOnly {
  __writableNotebooksOnly = writableNotebooksOnly;
  __writableNotebooksOnly_isset = YES;
}

- (BOOL) writableNotebooksOnlyIsSet {
  return __writableNotebooksOnly_isset;
}

- (void) unsetWritableNotebooksOnly {
  __writableNotebooksOnly_isset = NO;
}

- (BOOL) includeContainingNotebooks {
  return __includeContainingNotebooks;
}

- (void) setIncludeContainingNotebooks: (BOOL) includeContainingNotebooks {
  __includeContainingNotebooks = includeContainingNotebooks;
  __includeContainingNotebooks_isset = YES;
}

- (BOOL) includeContainingNotebooksIsSet {
  return __includeContainingNotebooks_isset;
}

- (void) unsetIncludeContainingNotebooks {
  __includeContainingNotebooks_isset = NO;
}

- (BOOL) includeDebugInfo {
  return __includeDebugInfo;
}

- (void) setIncludeDebugInfo: (BOOL) includeDebugInfo {
  __includeDebugInfo = includeDebugInfo;
  __includeDebugInfo_isset = YES;
}

- (BOOL) includeDebugInfoIsSet {
  return __includeDebugInfo_isset;
}

- (void) unsetIncludeDebugInfo {
  __includeDebugInfo_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxNotebooks: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxTags: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWritableNotebooksOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeContainingNotebooks: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeDebugInfo: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RelatedResultSpec"];
  if (__maxNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __maxNotes];
    [outProtocol writeFieldEnd];
  }
  if (__maxNotebooks_isset) {
    [outProtocol writeFieldBeginWithName: @"maxNotebooks" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __maxNotebooks];
    [outProtocol writeFieldEnd];
  }
  if (__maxTags_isset) {
    [outProtocol writeFieldBeginWithName: @"maxTags" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __maxTags];
    [outProtocol writeFieldEnd];
  }
  if (__writableNotebooksOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"writableNotebooksOnly" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __writableNotebooksOnly];
    [outProtocol writeFieldEnd];
  }
  if (__includeContainingNotebooks_isset) {
    [outProtocol writeFieldBeginWithName: @"includeContainingNotebooks" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __includeContainingNotebooks];
    [outProtocol writeFieldEnd];
  }
  if (__includeDebugInfo_isset) {
    [outProtocol writeFieldBeginWithName: @"includeDebugInfo" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __includeDebugInfo];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RelatedResultSpec("];
  [ms appendString: @"maxNotes:"];
  [ms appendFormat: @"%i", __maxNotes];
  [ms appendString: @",maxNotebooks:"];
  [ms appendFormat: @"%i", __maxNotebooks];
  [ms appendString: @",maxTags:"];
  [ms appendFormat: @"%i", __maxTags];
  [ms appendString: @",writableNotebooksOnly:"];
  [ms appendFormat: @"%i", __writableNotebooksOnly];
  [ms appendString: @",includeContainingNotebooks:"];
  [ms appendFormat: @"%i", __includeContainingNotebooks];
  [ms appendString: @",includeDebugInfo:"];
  [ms appendFormat: @"%i", __includeDebugInfo];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation EDAMNoteStoreConstants
+ (void) initialize {
}
@end

@interface EDAMgetSyncState_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMgetSyncState_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSyncState_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSyncState_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSyncState_result : NSObject <NSCoding> {
  EDAMSyncState * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSyncState * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSyncState *) success;
- (void) setSuccess: (EDAMSyncState *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetSyncState_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMSyncState *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSyncState *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncState *fieldValue = [[EDAMSyncState alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSyncState_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSyncState_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSyncStateWithMetrics_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMClientUsageMetrics * __clientMetrics;

  BOOL __authenticationToken_isset;
  BOOL __clientMetrics_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=clientMetrics, setter=setClientMetrics:) EDAMClientUsageMetrics * clientMetrics;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken clientMetrics: (EDAMClientUsageMetrics *) clientMetrics;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMClientUsageMetrics *) clientMetrics;
- (void) setClientMetrics: (EDAMClientUsageMetrics *) clientMetrics;
#endif
- (BOOL) clientMetricsIsSet;

@end

@implementation EDAMgetSyncStateWithMetrics_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken clientMetrics: (EDAMClientUsageMetrics *) clientMetrics
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __clientMetrics = [clientMetrics retain_stub];
  __clientMetrics_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"clientMetrics"])
  {
    __clientMetrics = [[decoder decodeObjectForKey: @"clientMetrics"] retain_stub];
    __clientMetrics_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__clientMetrics_isset)
  {
    [encoder encodeObject: __clientMetrics forKey: @"clientMetrics"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__clientMetrics release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMClientUsageMetrics *) clientMetrics {
  return [[__clientMetrics retain_stub] autorelease_stub];
}

- (void) setClientMetrics: (EDAMClientUsageMetrics *) clientMetrics {
  [clientMetrics retain_stub];
  [__clientMetrics release_stub];
  __clientMetrics = clientMetrics;
  __clientMetrics_isset = YES;
}

- (BOOL) clientMetricsIsSet {
  return __clientMetrics_isset;
}

- (void) unsetClientMetrics {
  [__clientMetrics release_stub];
  __clientMetrics = nil;
  __clientMetrics_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMClientUsageMetrics *fieldValue = [[EDAMClientUsageMetrics alloc] init];
          [fieldValue read: inProtocol];
          [self setClientMetrics: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSyncStateWithMetrics_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__clientMetrics_isset) {
    if (__clientMetrics != nil) {
      [outProtocol writeFieldBeginWithName: @"clientMetrics" type: TType_STRUCT fieldID: 2];
      [__clientMetrics write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSyncStateWithMetrics_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",clientMetrics:"];
  [ms appendFormat: @"%@", __clientMetrics];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSyncStateWithMetrics_result : NSObject <NSCoding> {
  EDAMSyncState * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSyncState * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSyncState *) success;
- (void) setSuccess: (EDAMSyncState *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetSyncStateWithMetrics_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMSyncState *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSyncState *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncState *fieldValue = [[EDAMSyncState alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSyncStateWithMetrics_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSyncStateWithMetrics_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSyncChunk_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  int32_t __afterUSN;
  int32_t __maxEntries;
  BOOL __fullSyncOnly;

  BOOL __authenticationToken_isset;
  BOOL __afterUSN_isset;
  BOOL __maxEntries_isset;
  BOOL __fullSyncOnly_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, getter=afterUSN, setter=setAfterUSN:) int32_t afterUSN;
@property (nonatomic, getter=maxEntries, setter=setMaxEntries:) int32_t maxEntries;
@property (nonatomic, getter=fullSyncOnly, setter=setFullSyncOnly:) BOOL fullSyncOnly;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (int32_t) afterUSN;
- (void) setAfterUSN: (int32_t) afterUSN;
#endif
- (BOOL) afterUSNIsSet;

#if !__has_feature(objc_arc)
- (int32_t) maxEntries;
- (void) setMaxEntries: (int32_t) maxEntries;
#endif
- (BOOL) maxEntriesIsSet;

#if !__has_feature(objc_arc)
- (BOOL) fullSyncOnly;
- (void) setFullSyncOnly: (BOOL) fullSyncOnly;
#endif
- (BOOL) fullSyncOnlyIsSet;

@end

@implementation EDAMgetSyncChunk_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"afterUSN"])
  {
    __afterUSN = [decoder decodeInt32ForKey: @"afterUSN"];
    __afterUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxEntries"])
  {
    __maxEntries = [decoder decodeInt32ForKey: @"maxEntries"];
    __maxEntries_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncOnly"])
  {
    __fullSyncOnly = [decoder decodeBoolForKey: @"fullSyncOnly"];
    __fullSyncOnly_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__afterUSN_isset)
  {
    [encoder encodeInt32: __afterUSN forKey: @"afterUSN"];
  }
  if (__maxEntries_isset)
  {
    [encoder encodeInt32: __maxEntries forKey: @"maxEntries"];
  }
  if (__fullSyncOnly_isset)
  {
    [encoder encodeBool: __fullSyncOnly forKey: @"fullSyncOnly"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (int32_t) afterUSN {
  return __afterUSN;
}

- (void) setAfterUSN: (int32_t) afterUSN {
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
}

- (BOOL) afterUSNIsSet {
  return __afterUSN_isset;
}

- (void) unsetAfterUSN {
  __afterUSN_isset = NO;
}

- (int32_t) maxEntries {
  return __maxEntries;
}

- (void) setMaxEntries: (int32_t) maxEntries {
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
}

- (BOOL) maxEntriesIsSet {
  return __maxEntries_isset;
}

- (void) unsetMaxEntries {
  __maxEntries_isset = NO;
}

- (BOOL) fullSyncOnly {
  return __fullSyncOnly;
}

- (void) setFullSyncOnly: (BOOL) fullSyncOnly {
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
}

- (BOOL) fullSyncOnlyIsSet {
  return __fullSyncOnly_isset;
}

- (void) unsetFullSyncOnly {
  __fullSyncOnly_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAfterUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxEntries: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setFullSyncOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSyncChunk_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__afterUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __afterUSN];
    [outProtocol writeFieldEnd];
  }
  if (__maxEntries_isset) {
    [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __maxEntries];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __fullSyncOnly];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSyncChunk_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",afterUSN:"];
  [ms appendFormat: @"%i", __afterUSN];
  [ms appendString: @",maxEntries:"];
  [ms appendFormat: @"%i", __maxEntries];
  [ms appendString: @",fullSyncOnly:"];
  [ms appendFormat: @"%i", __fullSyncOnly];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSyncChunk_result : NSObject <NSCoding> {
  EDAMSyncChunk * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSyncChunk * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSyncChunk *) success;
- (void) setSuccess: (EDAMSyncChunk *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetSyncChunk_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMSyncChunk *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSyncChunk *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunk *fieldValue = [[EDAMSyncChunk alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSyncChunk_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSyncChunk_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetFilteredSyncChunk_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  int32_t __afterUSN;
  int32_t __maxEntries;
  EDAMSyncChunkFilter * __filter;

  BOOL __authenticationToken_isset;
  BOOL __afterUSN_isset;
  BOOL __maxEntries_isset;
  BOOL __filter_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, getter=afterUSN, setter=setAfterUSN:) int32_t afterUSN;
@property (nonatomic, getter=maxEntries, setter=setMaxEntries:) int32_t maxEntries;
@property (nonatomic, strong, getter=filter, setter=setFilter:) EDAMSyncChunkFilter * filter;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries filter: (EDAMSyncChunkFilter *) filter;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (int32_t) afterUSN;
- (void) setAfterUSN: (int32_t) afterUSN;
#endif
- (BOOL) afterUSNIsSet;

#if !__has_feature(objc_arc)
- (int32_t) maxEntries;
- (void) setMaxEntries: (int32_t) maxEntries;
#endif
- (BOOL) maxEntriesIsSet;

#if !__has_feature(objc_arc)
- (EDAMSyncChunkFilter *) filter;
- (void) setFilter: (EDAMSyncChunkFilter *) filter;
#endif
- (BOOL) filterIsSet;

@end

@implementation EDAMgetFilteredSyncChunk_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries filter: (EDAMSyncChunkFilter *) filter
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
  __filter = [filter retain_stub];
  __filter_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"afterUSN"])
  {
    __afterUSN = [decoder decodeInt32ForKey: @"afterUSN"];
    __afterUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxEntries"])
  {
    __maxEntries = [decoder decodeInt32ForKey: @"maxEntries"];
    __maxEntries_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain_stub];
    __filter_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__afterUSN_isset)
  {
    [encoder encodeInt32: __afterUSN forKey: @"afterUSN"];
  }
  if (__maxEntries_isset)
  {
    [encoder encodeInt32: __maxEntries forKey: @"maxEntries"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__filter release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (int32_t) afterUSN {
  return __afterUSN;
}

- (void) setAfterUSN: (int32_t) afterUSN {
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
}

- (BOOL) afterUSNIsSet {
  return __afterUSN_isset;
}

- (void) unsetAfterUSN {
  __afterUSN_isset = NO;
}

- (int32_t) maxEntries {
  return __maxEntries;
}

- (void) setMaxEntries: (int32_t) maxEntries {
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
}

- (BOOL) maxEntriesIsSet {
  return __maxEntries_isset;
}

- (void) unsetMaxEntries {
  __maxEntries_isset = NO;
}

- (EDAMSyncChunkFilter *) filter {
  return [[__filter retain_stub] autorelease_stub];
}

- (void) setFilter: (EDAMSyncChunkFilter *) filter {
  [filter retain_stub];
  [__filter release_stub];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release_stub];
  __filter = nil;
  __filter_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAfterUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxEntries: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunkFilter *fieldValue = [[EDAMSyncChunkFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getFilteredSyncChunk_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__afterUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __afterUSN];
    [outProtocol writeFieldEnd];
  }
  if (__maxEntries_isset) {
    [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __maxEntries];
    [outProtocol writeFieldEnd];
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 4];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getFilteredSyncChunk_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",afterUSN:"];
  [ms appendFormat: @"%i", __afterUSN];
  [ms appendString: @",maxEntries:"];
  [ms appendFormat: @"%i", __maxEntries];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetFilteredSyncChunk_result : NSObject <NSCoding> {
  EDAMSyncChunk * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSyncChunk * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSyncChunk *) success;
- (void) setSuccess: (EDAMSyncChunk *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetFilteredSyncChunk_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMSyncChunk *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSyncChunk *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunk *fieldValue = [[EDAMSyncChunk alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetFilteredSyncChunk_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetFilteredSyncChunk_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetLinkedNotebookSyncState_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;
#endif
- (BOOL) linkedNotebookIsSet;

@end

@implementation EDAMgetLinkedNotebookSyncState_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain_stub];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain_stub];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__linkedNotebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain_stub] autorelease_stub];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain_stub];
  [__linkedNotebook release_stub];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release_stub];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncState_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getLinkedNotebookSyncState_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetLinkedNotebookSyncState_result : NSObject <NSCoding> {
  EDAMSyncState * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSyncState * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSyncState *) success;
- (void) setSuccess: (EDAMSyncState *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetLinkedNotebookSyncState_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMSyncState *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSyncState *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncState *fieldValue = [[EDAMSyncState alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetLinkedNotebookSyncState_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetLinkedNotebookSyncState_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetLinkedNotebookSyncChunk_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;
  int32_t __afterUSN;
  int32_t __maxEntries;
  BOOL __fullSyncOnly;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
  BOOL __afterUSN_isset;
  BOOL __maxEntries_isset;
  BOOL __fullSyncOnly_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
@property (nonatomic, getter=afterUSN, setter=setAfterUSN:) int32_t afterUSN;
@property (nonatomic, getter=maxEntries, setter=setMaxEntries:) int32_t maxEntries;
@property (nonatomic, getter=fullSyncOnly, setter=setFullSyncOnly:) BOOL fullSyncOnly;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;
#endif
- (BOOL) linkedNotebookIsSet;

#if !__has_feature(objc_arc)
- (int32_t) afterUSN;
- (void) setAfterUSN: (int32_t) afterUSN;
#endif
- (BOOL) afterUSNIsSet;

#if !__has_feature(objc_arc)
- (int32_t) maxEntries;
- (void) setMaxEntries: (int32_t) maxEntries;
#endif
- (BOOL) maxEntriesIsSet;

#if !__has_feature(objc_arc)
- (BOOL) fullSyncOnly;
- (void) setFullSyncOnly: (BOOL) fullSyncOnly;
#endif
- (BOOL) fullSyncOnlyIsSet;

@end

@implementation EDAMgetLinkedNotebookSyncChunk_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain_stub];
  __linkedNotebook_isset = YES;
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain_stub];
    __linkedNotebook_isset = YES;
  }
  if ([decoder containsValueForKey: @"afterUSN"])
  {
    __afterUSN = [decoder decodeInt32ForKey: @"afterUSN"];
    __afterUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxEntries"])
  {
    __maxEntries = [decoder decodeInt32ForKey: @"maxEntries"];
    __maxEntries_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncOnly"])
  {
    __fullSyncOnly = [decoder decodeBoolForKey: @"fullSyncOnly"];
    __fullSyncOnly_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
  if (__afterUSN_isset)
  {
    [encoder encodeInt32: __afterUSN forKey: @"afterUSN"];
  }
  if (__maxEntries_isset)
  {
    [encoder encodeInt32: __maxEntries forKey: @"maxEntries"];
  }
  if (__fullSyncOnly_isset)
  {
    [encoder encodeBool: __fullSyncOnly forKey: @"fullSyncOnly"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__linkedNotebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain_stub] autorelease_stub];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain_stub];
  [__linkedNotebook release_stub];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release_stub];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (int32_t) afterUSN {
  return __afterUSN;
}

- (void) setAfterUSN: (int32_t) afterUSN {
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
}

- (BOOL) afterUSNIsSet {
  return __afterUSN_isset;
}

- (void) unsetAfterUSN {
  __afterUSN_isset = NO;
}

- (int32_t) maxEntries {
  return __maxEntries;
}

- (void) setMaxEntries: (int32_t) maxEntries {
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
}

- (BOOL) maxEntriesIsSet {
  return __maxEntries_isset;
}

- (void) unsetMaxEntries {
  __maxEntries_isset = NO;
}

- (BOOL) fullSyncOnly {
  return __fullSyncOnly;
}

- (void) setFullSyncOnly: (BOOL) fullSyncOnly {
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
}

- (BOOL) fullSyncOnlyIsSet {
  return __fullSyncOnly_isset;
}

- (void) unsetFullSyncOnly {
  __fullSyncOnly_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAfterUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxEntries: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setFullSyncOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncChunk_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__afterUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __afterUSN];
    [outProtocol writeFieldEnd];
  }
  if (__maxEntries_isset) {
    [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __maxEntries];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __fullSyncOnly];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getLinkedNotebookSyncChunk_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @",afterUSN:"];
  [ms appendFormat: @"%i", __afterUSN];
  [ms appendString: @",maxEntries:"];
  [ms appendFormat: @"%i", __maxEntries];
  [ms appendString: @",fullSyncOnly:"];
  [ms appendFormat: @"%i", __fullSyncOnly];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetLinkedNotebookSyncChunk_result : NSObject <NSCoding> {
  EDAMSyncChunk * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSyncChunk * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSyncChunk *) success;
- (void) setSuccess: (EDAMSyncChunk *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetLinkedNotebookSyncChunk_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMSyncChunk *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSyncChunk *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunk *fieldValue = [[EDAMSyncChunk alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetLinkedNotebookSyncChunk_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetLinkedNotebookSyncChunk_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistNotebooks_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListNotebooks_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListNotebooks_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size137;
          [inProtocol readListBeginReturningElementType: NULL size: &_size137];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size137];
          int _i138;
          for (_i138 = 0; _i138 < _size137; ++_i138)
          {
            EDAMNotebook *_elem139 = [[EDAMNotebook alloc] init];
            [_elem139 read: inProtocol];
            [fieldValue addObject: _elem139];
            [_elem139 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i141;
        for (i141 = 0; i141 < [__success count]; i141++)
        {
          [[__success objectAtIndex: i141] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNotebook *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetDefaultNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMgetDefaultNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getDefaultNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getDefaultNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetDefaultNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetDefaultNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMNotebook *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetDefaultNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetDefaultNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNotebook * __notebook;

  BOOL __authenticationToken_isset;
  BOOL __notebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=notebook, setter=setNotebook:) EDAMNotebook * notebook;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotebook *) notebook;
- (void) setNotebook: (EDAMNotebook *) notebook;
#endif
- (BOOL) notebookIsSet;

@end

@implementation EDAMcreateNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __notebook = [notebook retain_stub];
  __notebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebook"])
  {
    __notebook = [[decoder decodeObjectForKey: @"notebook"] retain_stub];
    __notebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebook_isset)
  {
    [encoder encodeObject: __notebook forKey: @"notebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__notebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNotebook *) notebook {
  return [[__notebook retain_stub] autorelease_stub];
}

- (void) setNotebook: (EDAMNotebook *) notebook {
  [notebook retain_stub];
  [__notebook release_stub];
  __notebook = notebook;
  __notebook_isset = YES;
}

- (BOOL) notebookIsSet {
  return __notebook_isset;
}

- (void) unsetNotebook {
  [__notebook release_stub];
  __notebook = nil;
  __notebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebook_isset) {
    if (__notebook != nil) {
      [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
      [__notebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebook:"];
  [ms appendFormat: @"%@", __notebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMNotebook *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNotebook * __notebook;

  BOOL __authenticationToken_isset;
  BOOL __notebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=notebook, setter=setNotebook:) EDAMNotebook * notebook;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotebook *) notebook;
- (void) setNotebook: (EDAMNotebook *) notebook;
#endif
- (BOOL) notebookIsSet;

@end

@implementation EDAMupdateNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __notebook = [notebook retain_stub];
  __notebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebook"])
  {
    __notebook = [[decoder decodeObjectForKey: @"notebook"] retain_stub];
    __notebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebook_isset)
  {
    [encoder encodeObject: __notebook forKey: @"notebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__notebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNotebook *) notebook {
  return [[__notebook retain_stub] autorelease_stub];
}

- (void) setNotebook: (EDAMNotebook *) notebook {
  [notebook retain_stub];
  [__notebook release_stub];
  __notebook = notebook;
  __notebook_isset = YES;
}

- (BOOL) notebookIsSet {
  return __notebook_isset;
}

- (void) unsetNotebook {
  [__notebook release_stub];
  __notebook = nil;
  __notebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebook_isset) {
    if (__notebook != nil) {
      [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
      [__notebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebook:"];
  [ms appendFormat: @"%@", __notebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistTags_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistTags_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listTags_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listTags_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListTags_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListTags_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size142;
          [inProtocol readListBeginReturningElementType: NULL size: &_size142];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size142];
          int _i143;
          for (_i143 = 0; _i143 < _size142; ++_i143)
          {
            EDAMTag *_elem144 = [[EDAMTag alloc] init];
            [_elem144 read: inProtocol];
            [fieldValue addObject: _elem144];
            [_elem144 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListTags_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i146;
        for (i146 = 0; i146 < [__success count]; i146++)
        {
          [[__success objectAtIndex: i146] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListTags_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistTagsByNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __notebookGuid;

  BOOL __authenticationToken_isset;
  BOOL __notebookGuid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=notebookGuid, setter=setNotebookGuid:) EDAMGuid notebookGuid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) notebookGuid;
- (void) setNotebookGuid: (EDAMGuid) notebookGuid;
#endif
- (BOOL) notebookGuidIsSet;

@end

@implementation EDAMlistTagsByNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __notebookGuid = [notebookGuid retain_stub];
  __notebookGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain_stub];
    __notebookGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__notebookGuid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain_stub] autorelease_stub];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain_stub];
  [__notebookGuid release_stub];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release_stub];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listTagsByNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listTagsByNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListTagsByNotebook_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMListTagsByNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size147;
          [inProtocol readListBeginReturningElementType: NULL size: &_size147];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size147];
          int _i148;
          for (_i148 = 0; _i148 < _size147; ++_i148)
          {
            EDAMTag *_elem149 = [[EDAMTag alloc] init];
            [_elem149 read: inProtocol];
            [fieldValue addObject: _elem149];
            [_elem149 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListTagsByNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i151;
        for (i151 = 0; i151 < [__success count]; i151++)
        {
          [[__success objectAtIndex: i151] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListTagsByNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetTag_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetTag_result : NSObject <NSCoding> {
  EDAMTag * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMTag * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMTag *) success;
- (void) setSuccess: (EDAMTag *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetTag_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMTag *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMTag *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetTag_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMTag * __tag;

  BOOL __authenticationToken_isset;
  BOOL __tag_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=tag, setter=setTag:) EDAMTag * tag;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMTag *) tag;
- (void) setTag: (EDAMTag *) tag;
#endif
- (BOOL) tagIsSet;

@end

@implementation EDAMcreateTag_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __tag = [tag retain_stub];
  __tag_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"tag"])
  {
    __tag = [[decoder decodeObjectForKey: @"tag"] retain_stub];
    __tag_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__tag_isset)
  {
    [encoder encodeObject: __tag forKey: @"tag"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__tag release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMTag *) tag {
  return [[__tag retain_stub] autorelease_stub];
}

- (void) setTag: (EDAMTag *) tag {
  [tag retain_stub];
  [__tag release_stub];
  __tag = tag;
  __tag_isset = YES;
}

- (BOOL) tagIsSet {
  return __tag_isset;
}

- (void) unsetTag {
  [__tag release_stub];
  __tag = nil;
  __tag_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setTag: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tag_isset) {
    if (__tag != nil) {
      [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
      [__tag write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",tag:"];
  [ms appendFormat: @"%@", __tag];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateTag_result : NSObject <NSCoding> {
  EDAMTag * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMTag * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMTag *) success;
- (void) setSuccess: (EDAMTag *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMCreateTag_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMTag *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMTag *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateTag_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMTag * __tag;

  BOOL __authenticationToken_isset;
  BOOL __tag_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=tag, setter=setTag:) EDAMTag * tag;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMTag *) tag;
- (void) setTag: (EDAMTag *) tag;
#endif
- (BOOL) tagIsSet;

@end

@implementation EDAMupdateTag_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __tag = [tag retain_stub];
  __tag_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"tag"])
  {
    __tag = [[decoder decodeObjectForKey: @"tag"] retain_stub];
    __tag_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__tag_isset)
  {
    [encoder encodeObject: __tag forKey: @"tag"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__tag release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMTag *) tag {
  return [[__tag retain_stub] autorelease_stub];
}

- (void) setTag: (EDAMTag *) tag {
  [tag retain_stub];
  [__tag release_stub];
  __tag = tag;
  __tag_isset = YES;
}

- (BOOL) tagIsSet {
  return __tag_isset;
}

- (void) unsetTag {
  [__tag release_stub];
  __tag = nil;
  __tag_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setTag: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tag_isset) {
    if (__tag != nil) {
      [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
      [__tag write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",tag:"];
  [ms appendFormat: @"%@", __tag];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateTag_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateTag_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateTag_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMuntagAll_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMuntagAll_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"untagAll_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"untagAll_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUntagAll_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithUserException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUntagAll_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithUserException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UntagAll_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UntagAll_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeTag_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeTag_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeTag_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeTag_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistSearches_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistSearches_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listSearches_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listSearches_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListSearches_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListSearches_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size152;
          [inProtocol readListBeginReturningElementType: NULL size: &_size152];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size152];
          int _i153;
          for (_i153 = 0; _i153 < _size152; ++_i153)
          {
            EDAMSavedSearch *_elem154 = [[EDAMSavedSearch alloc] init];
            [_elem154 read: inProtocol];
            [fieldValue addObject: _elem154];
            [_elem154 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListSearches_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i156;
        for (i156 = 0; i156 < [__success count]; i156++)
        {
          [[__success objectAtIndex: i156] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListSearches_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetSearch_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSearch_result : NSObject <NSCoding> {
  EDAMSavedSearch * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSavedSearch * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSavedSearch *) success;
- (void) setSuccess: (EDAMSavedSearch *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetSearch_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMSavedSearch *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSavedSearch *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSearch_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSavedSearch * __search;

  BOOL __authenticationToken_isset;
  BOOL __search_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=search, setter=setSearch:) EDAMSavedSearch * search;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMSavedSearch *) search;
- (void) setSearch: (EDAMSavedSearch *) search;
#endif
- (BOOL) searchIsSet;

@end

@implementation EDAMcreateSearch_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __search = [search retain_stub];
  __search_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"search"])
  {
    __search = [[decoder decodeObjectForKey: @"search"] retain_stub];
    __search_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__search_isset)
  {
    [encoder encodeObject: __search forKey: @"search"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__search release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSavedSearch *) search {
  return [[__search retain_stub] autorelease_stub];
}

- (void) setSearch: (EDAMSavedSearch *) search {
  [search retain_stub];
  [__search release_stub];
  __search = search;
  __search_isset = YES;
}

- (BOOL) searchIsSet {
  return __search_isset;
}

- (void) unsetSearch {
  [__search release_stub];
  __search = nil;
  __search_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSearch: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__search_isset) {
    if (__search != nil) {
      [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
      [__search write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",search:"];
  [ms appendFormat: @"%@", __search];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateSearch_result : NSObject <NSCoding> {
  EDAMSavedSearch * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSavedSearch * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSavedSearch *) success;
- (void) setSuccess: (EDAMSavedSearch *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateSearch_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMSavedSearch *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSavedSearch *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateSearch_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSavedSearch * __search;

  BOOL __authenticationToken_isset;
  BOOL __search_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=search, setter=setSearch:) EDAMSavedSearch * search;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMSavedSearch *) search;
- (void) setSearch: (EDAMSavedSearch *) search;
#endif
- (BOOL) searchIsSet;

@end

@implementation EDAMupdateSearch_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __search = [search retain_stub];
  __search_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"search"])
  {
    __search = [[decoder decodeObjectForKey: @"search"] retain_stub];
    __search_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__search_isset)
  {
    [encoder encodeObject: __search forKey: @"search"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__search release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSavedSearch *) search {
  return [[__search retain_stub] autorelease_stub];
}

- (void) setSearch: (EDAMSavedSearch *) search {
  [search retain_stub];
  [__search release_stub];
  __search = search;
  __search_isset = YES;
}

- (BOOL) searchIsSet {
  return __search_isset;
}

- (void) unsetSearch {
  [__search release_stub];
  __search = nil;
  __search_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSearch: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__search_isset) {
    if (__search != nil) {
      [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
      [__search write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",search:"];
  [ms appendFormat: @"%@", __search];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateSearch_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateSearch_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateSearch_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeSearch_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeSearch_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeSearch_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeSearch_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  int32_t __offset;
  int32_t __maxNotes;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __offset_isset;
  BOOL __maxNotes_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=offset, setter=setOffset:) int32_t offset;
@property (nonatomic, getter=maxNotes, setter=setMaxNotes:) int32_t maxNotes;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;
#endif
- (BOOL) filterIsSet;

#if !__has_feature(objc_arc)
- (int32_t) offset;
- (void) setOffset: (int32_t) offset;
#endif
- (BOOL) offsetIsSet;

#if !__has_feature(objc_arc)
- (int32_t) maxNotes;
- (void) setMaxNotes: (int32_t) maxNotes;
#endif
- (BOOL) maxNotesIsSet;

@end

@implementation EDAMfindNotes_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __filter = [filter retain_stub];
  __filter_isset = YES;
  __offset = offset;
  __offset_isset = YES;
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain_stub];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"offset"])
  {
    __offset = [decoder decodeInt32ForKey: @"offset"];
    __offset_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxNotes"])
  {
    __maxNotes = [decoder decodeInt32ForKey: @"maxNotes"];
    __maxNotes_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__offset_isset)
  {
    [encoder encodeInt32: __offset forKey: @"offset"];
  }
  if (__maxNotes_isset)
  {
    [encoder encodeInt32: __maxNotes forKey: @"maxNotes"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__filter release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain_stub] autorelease_stub];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain_stub];
  [__filter release_stub];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release_stub];
  __filter = nil;
  __filter_isset = NO;
}

- (int32_t) offset {
  return __offset;
}

- (void) setOffset: (int32_t) offset {
  __offset = offset;
  __offset_isset = YES;
}

- (BOOL) offsetIsSet {
  return __offset_isset;
}

- (void) unsetOffset {
  __offset_isset = NO;
}

- (int32_t) maxNotes {
  return __maxNotes;
}

- (void) setMaxNotes: (int32_t) maxNotes {
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
}

- (BOOL) maxNotesIsSet {
  return __maxNotes_isset;
}

- (void) unsetMaxNotes {
  __maxNotes_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOffset: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__offset_isset) {
    [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __offset];
    [outProtocol writeFieldEnd];
  }
  if (__maxNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __maxNotes];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",offset:"];
  [ms appendFormat: @"%i", __offset];
  [ms appendString: @",maxNotes:"];
  [ms appendFormat: @"%i", __maxNotes];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNotes_result : NSObject <NSCoding> {
  EDAMNoteList * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNoteList * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNoteList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNoteList *) success;
- (void) setSuccess: (EDAMNoteList *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMFindNotes_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNoteList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNoteList *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNoteList *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNoteList *fieldValue = [[EDAMNoteList alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNotes_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNoteOffset_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;
#endif
- (BOOL) filterIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMfindNoteOffset_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __filter = [filter retain_stub];
  __filter_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain_stub];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__filter release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain_stub] autorelease_stub];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain_stub];
  [__filter release_stub];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release_stub];
  __filter = nil;
  __filter_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNoteOffset_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNoteOffset_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNoteOffset_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMFindNoteOffset_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNoteOffset_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNoteOffset_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNotesMetadata_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  int32_t __offset;
  int32_t __maxNotes;
  EDAMNotesMetadataResultSpec * __resultSpec;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __offset_isset;
  BOOL __maxNotes_isset;
  BOOL __resultSpec_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=offset, setter=setOffset:) int32_t offset;
@property (nonatomic, getter=maxNotes, setter=setMaxNotes:) int32_t maxNotes;
@property (nonatomic, strong, getter=resultSpec, setter=setResultSpec:) EDAMNotesMetadataResultSpec * resultSpec;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes resultSpec: (EDAMNotesMetadataResultSpec *) resultSpec;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;
#endif
- (BOOL) filterIsSet;

#if !__has_feature(objc_arc)
- (int32_t) offset;
- (void) setOffset: (int32_t) offset;
#endif
- (BOOL) offsetIsSet;

#if !__has_feature(objc_arc)
- (int32_t) maxNotes;
- (void) setMaxNotes: (int32_t) maxNotes;
#endif
- (BOOL) maxNotesIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotesMetadataResultSpec *) resultSpec;
- (void) setResultSpec: (EDAMNotesMetadataResultSpec *) resultSpec;
#endif
- (BOOL) resultSpecIsSet;

@end

@implementation EDAMfindNotesMetadata_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes resultSpec: (EDAMNotesMetadataResultSpec *) resultSpec
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __filter = [filter retain_stub];
  __filter_isset = YES;
  __offset = offset;
  __offset_isset = YES;
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
  __resultSpec = [resultSpec retain_stub];
  __resultSpec_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain_stub];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"offset"])
  {
    __offset = [decoder decodeInt32ForKey: @"offset"];
    __offset_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxNotes"])
  {
    __maxNotes = [decoder decodeInt32ForKey: @"maxNotes"];
    __maxNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"resultSpec"])
  {
    __resultSpec = [[decoder decodeObjectForKey: @"resultSpec"] retain_stub];
    __resultSpec_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__offset_isset)
  {
    [encoder encodeInt32: __offset forKey: @"offset"];
  }
  if (__maxNotes_isset)
  {
    [encoder encodeInt32: __maxNotes forKey: @"maxNotes"];
  }
  if (__resultSpec_isset)
  {
    [encoder encodeObject: __resultSpec forKey: @"resultSpec"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__filter release_stub];
  [__resultSpec release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain_stub] autorelease_stub];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain_stub];
  [__filter release_stub];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release_stub];
  __filter = nil;
  __filter_isset = NO;
}

- (int32_t) offset {
  return __offset;
}

- (void) setOffset: (int32_t) offset {
  __offset = offset;
  __offset_isset = YES;
}

- (BOOL) offsetIsSet {
  return __offset_isset;
}

- (void) unsetOffset {
  __offset_isset = NO;
}

- (int32_t) maxNotes {
  return __maxNotes;
}

- (void) setMaxNotes: (int32_t) maxNotes {
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
}

- (BOOL) maxNotesIsSet {
  return __maxNotes_isset;
}

- (void) unsetMaxNotes {
  __maxNotes_isset = NO;
}

- (EDAMNotesMetadataResultSpec *) resultSpec {
  return [[__resultSpec retain_stub] autorelease_stub];
}

- (void) setResultSpec: (EDAMNotesMetadataResultSpec *) resultSpec {
  [resultSpec retain_stub];
  [__resultSpec release_stub];
  __resultSpec = resultSpec;
  __resultSpec_isset = YES;
}

- (BOOL) resultSpecIsSet {
  return __resultSpec_isset;
}

- (void) unsetResultSpec {
  [__resultSpec release_stub];
  __resultSpec = nil;
  __resultSpec_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOffset: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRUCT) {
          EDAMNotesMetadataResultSpec *fieldValue = [[EDAMNotesMetadataResultSpec alloc] init];
          [fieldValue read: inProtocol];
          [self setResultSpec: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNotesMetadata_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__offset_isset) {
    [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __offset];
    [outProtocol writeFieldEnd];
  }
  if (__maxNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __maxNotes];
    [outProtocol writeFieldEnd];
  }
  if (__resultSpec_isset) {
    if (__resultSpec != nil) {
      [outProtocol writeFieldBeginWithName: @"resultSpec" type: TType_STRUCT fieldID: 5];
      [__resultSpec write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNotesMetadata_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",offset:"];
  [ms appendFormat: @"%i", __offset];
  [ms appendString: @",maxNotes:"];
  [ms appendFormat: @"%i", __maxNotes];
  [ms appendString: @",resultSpec:"];
  [ms appendFormat: @"%@", __resultSpec];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNotesMetadata_result : NSObject <NSCoding> {
  EDAMNotesMetadataList * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNotesMetadataList * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNotesMetadataList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNotesMetadataList *) success;
- (void) setSuccess: (EDAMNotesMetadataList *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMFindNotesMetadata_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNotesMetadataList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNotesMetadataList *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNotesMetadataList *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotesMetadataList *fieldValue = [[EDAMNotesMetadataList alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNotesMetadata_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNotesMetadata_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNoteCounts_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  BOOL __withTrash;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __withTrash_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=withTrash, setter=setWithTrash:) BOOL withTrash;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;
#endif
- (BOOL) filterIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withTrash;
- (void) setWithTrash: (BOOL) withTrash;
#endif
- (BOOL) withTrashIsSet;

@end

@implementation EDAMfindNoteCounts_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __filter = [filter retain_stub];
  __filter_isset = YES;
  __withTrash = withTrash;
  __withTrash_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain_stub];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"withTrash"])
  {
    __withTrash = [decoder decodeBoolForKey: @"withTrash"];
    __withTrash_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__withTrash_isset)
  {
    [encoder encodeBool: __withTrash forKey: @"withTrash"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__filter release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain_stub] autorelease_stub];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain_stub];
  [__filter release_stub];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release_stub];
  __filter = nil;
  __filter_isset = NO;
}

- (BOOL) withTrash {
  return __withTrash;
}

- (void) setWithTrash: (BOOL) withTrash {
  __withTrash = withTrash;
  __withTrash_isset = YES;
}

- (BOOL) withTrashIsSet {
  return __withTrash_isset;
}

- (void) unsetWithTrash {
  __withTrash_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithTrash: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNoteCounts_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withTrash_isset) {
    [outProtocol writeFieldBeginWithName: @"withTrash" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withTrash];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNoteCounts_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",withTrash:"];
  [ms appendFormat: @"%i", __withTrash];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNoteCounts_result : NSObject <NSCoding> {
  EDAMNoteCollectionCounts * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNoteCollectionCounts * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNoteCollectionCounts *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNoteCollectionCounts *) success;
- (void) setSuccess: (EDAMNoteCollectionCounts *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMFindNoteCounts_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNoteCollectionCounts *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNoteCollectionCounts *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNoteCollectionCounts *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNoteCollectionCounts *fieldValue = [[EDAMNoteCollectionCounts alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNoteCounts_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNoteCounts_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __withContent;
  BOOL __withResourcesData;
  BOOL __withResourcesRecognition;
  BOOL __withResourcesAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __withContent_isset;
  BOOL __withResourcesData_isset;
  BOOL __withResourcesRecognition_isset;
  BOOL __withResourcesAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=withContent, setter=setWithContent:) BOOL withContent;
@property (nonatomic, getter=withResourcesData, setter=setWithResourcesData:) BOOL withResourcesData;
@property (nonatomic, getter=withResourcesRecognition, setter=setWithResourcesRecognition:) BOOL withResourcesRecognition;
@property (nonatomic, getter=withResourcesAlternateData, setter=setWithResourcesAlternateData:) BOOL withResourcesAlternateData;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withContent;
- (void) setWithContent: (BOOL) withContent;
#endif
- (BOOL) withContentIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withResourcesData;
- (void) setWithResourcesData: (BOOL) withResourcesData;
#endif
- (BOOL) withResourcesDataIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withResourcesRecognition;
- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition;
#endif
- (BOOL) withResourcesRecognitionIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withResourcesAlternateData;
- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData;
#endif
- (BOOL) withResourcesAlternateDataIsSet;

@end

@implementation EDAMgetNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __withContent = withContent;
  __withContent_isset = YES;
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"withContent"])
  {
    __withContent = [decoder decodeBoolForKey: @"withContent"];
    __withContent_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesData"])
  {
    __withResourcesData = [decoder decodeBoolForKey: @"withResourcesData"];
    __withResourcesData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesRecognition"])
  {
    __withResourcesRecognition = [decoder decodeBoolForKey: @"withResourcesRecognition"];
    __withResourcesRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesAlternateData"])
  {
    __withResourcesAlternateData = [decoder decodeBoolForKey: @"withResourcesAlternateData"];
    __withResourcesAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__withContent_isset)
  {
    [encoder encodeBool: __withContent forKey: @"withContent"];
  }
  if (__withResourcesData_isset)
  {
    [encoder encodeBool: __withResourcesData forKey: @"withResourcesData"];
  }
  if (__withResourcesRecognition_isset)
  {
    [encoder encodeBool: __withResourcesRecognition forKey: @"withResourcesRecognition"];
  }
  if (__withResourcesAlternateData_isset)
  {
    [encoder encodeBool: __withResourcesAlternateData forKey: @"withResourcesAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) withContent {
  return __withContent;
}

- (void) setWithContent: (BOOL) withContent {
  __withContent = withContent;
  __withContent_isset = YES;
}

- (BOOL) withContentIsSet {
  return __withContent_isset;
}

- (void) unsetWithContent {
  __withContent_isset = NO;
}

- (BOOL) withResourcesData {
  return __withResourcesData;
}

- (void) setWithResourcesData: (BOOL) withResourcesData {
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
}

- (BOOL) withResourcesDataIsSet {
  return __withResourcesData_isset;
}

- (void) unsetWithResourcesData {
  __withResourcesData_isset = NO;
}

- (BOOL) withResourcesRecognition {
  return __withResourcesRecognition;
}

- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition {
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
}

- (BOOL) withResourcesRecognitionIsSet {
  return __withResourcesRecognition_isset;
}

- (void) unsetWithResourcesRecognition {
  __withResourcesRecognition_isset = NO;
}

- (BOOL) withResourcesAlternateData {
  return __withResourcesAlternateData;
}

- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData {
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
}

- (BOOL) withResourcesAlternateDataIsSet {
  return __withResourcesAlternateData_isset;
}

- (void) unsetWithResourcesAlternateData {
  __withResourcesAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithContent: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withContent_isset) {
    [outProtocol writeFieldBeginWithName: @"withContent" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withContent];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withResourcesData];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withResourcesRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withResourcesAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",withContent:"];
  [ms appendFormat: @"%i", __withContent];
  [ms appendString: @",withResourcesData:"];
  [ms appendFormat: @"%i", __withResourcesData];
  [ms appendString: @",withResourcesRecognition:"];
  [ms appendFormat: @"%i", __withResourcesRecognition];
  [ms appendString: @",withResourcesAlternateData:"];
  [ms appendFormat: @"%i", __withResourcesAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNote *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteApplicationData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNoteApplicationData_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteApplicationData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteApplicationData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteApplicationData_result : NSObject <NSCoding> {
  EDAMLazyMap * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMLazyMap * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMLazyMap *) success;
- (void) setSuccess: (EDAMLazyMap *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteApplicationData_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMLazyMap *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMLazyMap *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLazyMap *fieldValue = [[EDAMLazyMap alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteApplicationData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteApplicationData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, strong, getter=key, setter=setKey:) NSString * key;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) key;
- (void) setKey: (NSString *) key;
#endif
- (BOOL) keyIsSet;

@end

@implementation EDAMgetNoteApplicationDataEntry_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [__key release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSString *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteApplicationDataEntry_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) success;
- (void) setSuccess: (NSString *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteApplicationDataEntry_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSString *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSString *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteApplicationDataEntry_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMsetNoteApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;
  NSString * __value;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
  BOOL __value_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, strong, getter=key, setter=setKey:) NSString * key;
@property (nonatomic, strong, getter=value, setter=setValue:) NSString * value;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) key;
- (void) setKey: (NSString *) key;
#endif
- (BOOL) keyIsSet;

#if !__has_feature(objc_arc)
- (NSString *) value;
- (void) setValue: (NSString *) value;
#endif
- (BOOL) valueIsSet;

@end

@implementation EDAMsetNoteApplicationDataEntry_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  __value = [value retain_stub];
  __value_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [[decoder decodeObjectForKey: @"value"] retain_stub];
    __value_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
  if (__value_isset)
  {
    [encoder encodeObject: __value forKey: @"value"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [__key release_stub];
  [__value release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSString *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (NSString *) value {
  return [[__value retain_stub] autorelease_stub];
}

- (void) setValue: (NSString *) value {
  [value retain_stub];
  [__value release_stub];
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  [__value release_stub];
  __value = nil;
  __value_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"setNoteApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__value_isset) {
    if (__value != nil) {
      [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __value];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"setNoteApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @",value:"];
  [ms appendFormat: @"\"%@\"", __value];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMSetNoteApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMSetNoteApplicationDataEntry_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SetNoteApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SetNoteApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMunsetNoteApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, strong, getter=key, setter=setKey:) NSString * key;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) key;
- (void) setKey: (NSString *) key;
#endif
- (BOOL) keyIsSet;

@end

@implementation EDAMunsetNoteApplicationDataEntry_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [__key release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSString *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"unsetNoteApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"unsetNoteApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUnsetNoteApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUnsetNoteApplicationDataEntry_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UnsetNoteApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UnsetNoteApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteContent_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNoteContent_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteContent_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteContent_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteContent_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) success;
- (void) setSuccess: (NSString *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteContent_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSString *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSString *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteContent_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteContent_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteSearchText_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __noteOnly;
  BOOL __tokenizeForIndexing;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __noteOnly_isset;
  BOOL __tokenizeForIndexing_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=noteOnly, setter=setNoteOnly:) BOOL noteOnly;
@property (nonatomic, getter=tokenizeForIndexing, setter=setTokenizeForIndexing:) BOOL tokenizeForIndexing;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid noteOnly: (BOOL) noteOnly tokenizeForIndexing: (BOOL) tokenizeForIndexing;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (BOOL) noteOnly;
- (void) setNoteOnly: (BOOL) noteOnly;
#endif
- (BOOL) noteOnlyIsSet;

#if !__has_feature(objc_arc)
- (BOOL) tokenizeForIndexing;
- (void) setTokenizeForIndexing: (BOOL) tokenizeForIndexing;
#endif
- (BOOL) tokenizeForIndexingIsSet;

@end

@implementation EDAMgetNoteSearchText_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid noteOnly: (BOOL) noteOnly tokenizeForIndexing: (BOOL) tokenizeForIndexing
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __noteOnly = noteOnly;
  __noteOnly_isset = YES;
  __tokenizeForIndexing = tokenizeForIndexing;
  __tokenizeForIndexing_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteOnly"])
  {
    __noteOnly = [decoder decodeBoolForKey: @"noteOnly"];
    __noteOnly_isset = YES;
  }
  if ([decoder containsValueForKey: @"tokenizeForIndexing"])
  {
    __tokenizeForIndexing = [decoder decodeBoolForKey: @"tokenizeForIndexing"];
    __tokenizeForIndexing_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__noteOnly_isset)
  {
    [encoder encodeBool: __noteOnly forKey: @"noteOnly"];
  }
  if (__tokenizeForIndexing_isset)
  {
    [encoder encodeBool: __tokenizeForIndexing forKey: @"tokenizeForIndexing"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) noteOnly {
  return __noteOnly;
}

- (void) setNoteOnly: (BOOL) noteOnly {
  __noteOnly = noteOnly;
  __noteOnly_isset = YES;
}

- (BOOL) noteOnlyIsSet {
  return __noteOnly_isset;
}

- (void) unsetNoteOnly {
  __noteOnly_isset = NO;
}

- (BOOL) tokenizeForIndexing {
  return __tokenizeForIndexing;
}

- (void) setTokenizeForIndexing: (BOOL) tokenizeForIndexing {
  __tokenizeForIndexing = tokenizeForIndexing;
  __tokenizeForIndexing_isset = YES;
}

- (BOOL) tokenizeForIndexingIsSet {
  return __tokenizeForIndexing_isset;
}

- (void) unsetTokenizeForIndexing {
  __tokenizeForIndexing_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setNoteOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setTokenizeForIndexing: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteSearchText_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"noteOnly" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __noteOnly];
    [outProtocol writeFieldEnd];
  }
  if (__tokenizeForIndexing_isset) {
    [outProtocol writeFieldBeginWithName: @"tokenizeForIndexing" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __tokenizeForIndexing];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteSearchText_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",noteOnly:"];
  [ms appendFormat: @"%i", __noteOnly];
  [ms appendString: @",tokenizeForIndexing:"];
  [ms appendFormat: @"%i", __tokenizeForIndexing];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteSearchText_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) success;
- (void) setSuccess: (NSString *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteSearchText_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSString *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSString *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteSearchText_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteSearchText_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceSearchText_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceSearchText_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceSearchText_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceSearchText_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceSearchText_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) success;
- (void) setSuccess: (NSString *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceSearchText_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSString *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSString *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceSearchText_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceSearchText_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteTagNames_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNoteTagNames_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteTagNames_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteTagNames_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteTagNames_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteTagNames_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size157;
          [inProtocol readListBeginReturningElementType: NULL size: &_size157];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size157];
          int _i158;
          for (_i158 = 0; _i158 < _size157; ++_i158)
          {
            NSString * _elem159 = [inProtocol readString];
            [fieldValue addObject: _elem159];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteTagNames_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__success count]];
        int i161;
        for (i161 = 0; i161 < [__success count]; i161++)
        {
          [outProtocol writeString: [__success objectAtIndex: i161]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteTagNames_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNote * __note;

  BOOL __authenticationToken_isset;
  BOOL __note_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=note, setter=setNote:) EDAMNote * note;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNote *) note;
- (void) setNote: (EDAMNote *) note;
#endif
- (BOOL) noteIsSet;

@end

@implementation EDAMcreateNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __note = [note retain_stub];
  __note_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain_stub];
    __note_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__note release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain_stub] autorelease_stub];
}

- (void) setNote: (EDAMNote *) note {
  [note retain_stub];
  [__note release_stub];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release_stub];
  __note = nil;
  __note_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMCreateNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNote *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNote * __note;

  BOOL __authenticationToken_isset;
  BOOL __note_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=note, setter=setNote:) EDAMNote * note;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNote *) note;
- (void) setNote: (EDAMNote *) note;
#endif
- (BOOL) noteIsSet;

@end

@implementation EDAMupdateNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __note = [note retain_stub];
  __note_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain_stub];
    __note_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__note release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain_stub] autorelease_stub];
}

- (void) setNote: (EDAMNote *) note {
  [note retain_stub];
  [__note release_stub];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release_stub];
  __note = nil;
  __note_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNote *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMdeleteNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMdeleteNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"deleteNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"deleteNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMDeleteNote_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMDeleteNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"DeleteNote_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"DeleteNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNote_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNote_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  NSMutableArray * __noteGuids;

  BOOL __authenticationToken_isset;
  BOOL __noteGuids_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=noteGuids, setter=setNoteGuids:) NSMutableArray * noteGuids;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuids: (NSMutableArray *) noteGuids;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (NSMutableArray *) noteGuids;
- (void) setNoteGuids: (NSMutableArray *) noteGuids;
#endif
- (BOOL) noteGuidsIsSet;

@end

@implementation EDAMexpungeNotes_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuids: (NSMutableArray *) noteGuids
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __noteGuids = [noteGuids retain_stub];
  __noteGuids_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuids"])
  {
    __noteGuids = [[decoder decodeObjectForKey: @"noteGuids"] retain_stub];
    __noteGuids_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuids_isset)
  {
    [encoder encodeObject: __noteGuids forKey: @"noteGuids"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__noteGuids release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSMutableArray *) noteGuids {
  return [[__noteGuids retain_stub] autorelease_stub];
}

- (void) setNoteGuids: (NSMutableArray *) noteGuids {
  [noteGuids retain_stub];
  [__noteGuids release_stub];
  __noteGuids = noteGuids;
  __noteGuids_isset = YES;
}

- (BOOL) noteGuidsIsSet {
  return __noteGuids_isset;
}

- (void) unsetNoteGuids {
  [__noteGuids release_stub];
  __noteGuids = nil;
  __noteGuids_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size162;
          [inProtocol readListBeginReturningElementType: NULL size: &_size162];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size162];
          int _i163;
          for (_i163 = 0; _i163 < _size162; ++_i163)
          {
            NSString * _elem164 = [inProtocol readString];
            [fieldValue addObject: _elem164];
          }
          [inProtocol readListEnd];
          [self setNoteGuids: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuids_isset) {
    if (__noteGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuids" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__noteGuids count]];
        int i166;
        for (i166 = 0; i166 < [__noteGuids count]; i166++)
        {
          [outProtocol writeString: [__noteGuids objectAtIndex: i166]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuids:"];
  [ms appendFormat: @"%@", __noteGuids];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNotes_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeNotes_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNotes_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeInactiveNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMexpungeInactiveNotes_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeInactiveNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeInactiveNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeInactiveNotes_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMExpungeInactiveNotes_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeInactiveNotes_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeInactiveNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcopyNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  EDAMGuid __toNotebookGuid;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __toNotebookGuid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, strong, getter=toNotebookGuid, setter=setToNotebookGuid:) EDAMGuid toNotebookGuid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
#endif
- (BOOL) noteGuidIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) toNotebookGuid;
- (void) setToNotebookGuid: (EDAMGuid) toNotebookGuid;
#endif
- (BOOL) toNotebookGuidIsSet;

@end

@implementation EDAMcopyNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain_stub];
  __noteGuid_isset = YES;
  __toNotebookGuid = [toNotebookGuid retain_stub];
  __toNotebookGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain_stub];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"toNotebookGuid"])
  {
    __toNotebookGuid = [[decoder decodeObjectForKey: @"toNotebookGuid"] retain_stub];
    __toNotebookGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__toNotebookGuid_isset)
  {
    [encoder encodeObject: __toNotebookGuid forKey: @"toNotebookGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__noteGuid release_stub];
  [__toNotebookGuid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain_stub] autorelease_stub];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain_stub];
  [__noteGuid release_stub];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release_stub];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (NSString *) toNotebookGuid {
  return [[__toNotebookGuid retain_stub] autorelease_stub];
}

- (void) setToNotebookGuid: (NSString *) toNotebookGuid {
  [toNotebookGuid retain_stub];
  [__toNotebookGuid release_stub];
  __toNotebookGuid = toNotebookGuid;
  __toNotebookGuid_isset = YES;
}

- (BOOL) toNotebookGuidIsSet {
  return __toNotebookGuid_isset;
}

- (void) unsetToNotebookGuid {
  [__toNotebookGuid release_stub];
  __toNotebookGuid = nil;
  __toNotebookGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setToNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"copyNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__toNotebookGuid_isset) {
    if (__toNotebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"toNotebookGuid" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __toNotebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"copyNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",toNotebookGuid:"];
  [ms appendFormat: @"\"%@\"", __toNotebookGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCopyNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMCopyNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNote *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CopyNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CopyNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistNoteVersions_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
#endif
- (BOOL) noteGuidIsSet;

@end

@implementation EDAMlistNoteVersions_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain_stub];
  __noteGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain_stub];
    __noteGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__noteGuid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain_stub] autorelease_stub];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain_stub];
  [__noteGuid release_stub];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release_stub];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listNoteVersions_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listNoteVersions_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListNoteVersions_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMListNoteVersions_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size167;
          [inProtocol readListBeginReturningElementType: NULL size: &_size167];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size167];
          int _i168;
          for (_i168 = 0; _i168 < _size167; ++_i168)
          {
            EDAMNoteVersionId *_elem169 = [[EDAMNoteVersionId alloc] init];
            [_elem169 read: inProtocol];
            [fieldValue addObject: _elem169];
            [_elem169 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListNoteVersions_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i171;
        for (i171 = 0; i171 < [__success count]; i171++)
        {
          [[__success objectAtIndex: i171] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListNoteVersions_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteVersion_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  int32_t __updateSequenceNum;
  BOOL __withResourcesData;
  BOOL __withResourcesRecognition;
  BOOL __withResourcesAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __updateSequenceNum_isset;
  BOOL __withResourcesData_isset;
  BOOL __withResourcesRecognition_isset;
  BOOL __withResourcesAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, getter=updateSequenceNum, setter=setUpdateSequenceNum:) int32_t updateSequenceNum;
@property (nonatomic, getter=withResourcesData, setter=setWithResourcesData:) BOOL withResourcesData;
@property (nonatomic, getter=withResourcesRecognition, setter=setWithResourcesRecognition:) BOOL withResourcesRecognition;
@property (nonatomic, getter=withResourcesAlternateData, setter=setWithResourcesAlternateData:) BOOL withResourcesAlternateData;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
#endif
- (BOOL) noteGuidIsSet;

#if !__has_feature(objc_arc)
- (int32_t) updateSequenceNum;
- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum;
#endif
- (BOOL) updateSequenceNumIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withResourcesData;
- (void) setWithResourcesData: (BOOL) withResourcesData;
#endif
- (BOOL) withResourcesDataIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withResourcesRecognition;
- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition;
#endif
- (BOOL) withResourcesRecognitionIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withResourcesAlternateData;
- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData;
#endif
- (BOOL) withResourcesAlternateDataIsSet;

@end

@implementation EDAMgetNoteVersion_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain_stub];
  __noteGuid_isset = YES;
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain_stub];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesData"])
  {
    __withResourcesData = [decoder decodeBoolForKey: @"withResourcesData"];
    __withResourcesData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesRecognition"])
  {
    __withResourcesRecognition = [decoder decodeBoolForKey: @"withResourcesRecognition"];
    __withResourcesRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesAlternateData"])
  {
    __withResourcesAlternateData = [decoder decodeBoolForKey: @"withResourcesAlternateData"];
    __withResourcesAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__withResourcesData_isset)
  {
    [encoder encodeBool: __withResourcesData forKey: @"withResourcesData"];
  }
  if (__withResourcesRecognition_isset)
  {
    [encoder encodeBool: __withResourcesRecognition forKey: @"withResourcesRecognition"];
  }
  if (__withResourcesAlternateData_isset)
  {
    [encoder encodeBool: __withResourcesAlternateData forKey: @"withResourcesAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__noteGuid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain_stub] autorelease_stub];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain_stub];
  [__noteGuid release_stub];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release_stub];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (BOOL) withResourcesData {
  return __withResourcesData;
}

- (void) setWithResourcesData: (BOOL) withResourcesData {
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
}

- (BOOL) withResourcesDataIsSet {
  return __withResourcesData_isset;
}

- (void) unsetWithResourcesData {
  __withResourcesData_isset = NO;
}

- (BOOL) withResourcesRecognition {
  return __withResourcesRecognition;
}

- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition {
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
}

- (BOOL) withResourcesRecognitionIsSet {
  return __withResourcesRecognition_isset;
}

- (void) unsetWithResourcesRecognition {
  __withResourcesRecognition_isset = NO;
}

- (BOOL) withResourcesAlternateData {
  return __withResourcesAlternateData;
}

- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData {
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
}

- (BOOL) withResourcesAlternateDataIsSet {
  return __withResourcesAlternateData_isset;
}

- (void) unsetWithResourcesAlternateData {
  __withResourcesAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteVersion_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withResourcesData];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withResourcesRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withResourcesAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteVersion_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",withResourcesData:"];
  [ms appendFormat: @"%i", __withResourcesData];
  [ms appendString: @",withResourcesRecognition:"];
  [ms appendFormat: @"%i", __withResourcesRecognition];
  [ms appendString: @",withResourcesAlternateData:"];
  [ms appendFormat: @"%i", __withResourcesAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteVersion_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteVersion_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNote *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteVersion_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteVersion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResource_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __withData;
  BOOL __withRecognition;
  BOOL __withAttributes;
  BOOL __withAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __withData_isset;
  BOOL __withRecognition_isset;
  BOOL __withAttributes_isset;
  BOOL __withAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=withData, setter=setWithData:) BOOL withData;
@property (nonatomic, getter=withRecognition, setter=setWithRecognition:) BOOL withRecognition;
@property (nonatomic, getter=withAttributes, setter=setWithAttributes:) BOOL withAttributes;
@property (nonatomic, getter=withAlternateData, setter=setWithAlternateData:) BOOL withAlternateData;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withData;
- (void) setWithData: (BOOL) withData;
#endif
- (BOOL) withDataIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withRecognition;
- (void) setWithRecognition: (BOOL) withRecognition;
#endif
- (BOOL) withRecognitionIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withAttributes;
- (void) setWithAttributes: (BOOL) withAttributes;
#endif
- (BOOL) withAttributesIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withAlternateData;
- (void) setWithAlternateData: (BOOL) withAlternateData;
#endif
- (BOOL) withAlternateDataIsSet;

@end

@implementation EDAMgetResource_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __withData = withData;
  __withData_isset = YES;
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
  __withAttributes = withAttributes;
  __withAttributes_isset = YES;
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"withData"])
  {
    __withData = [decoder decodeBoolForKey: @"withData"];
    __withData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withRecognition"])
  {
    __withRecognition = [decoder decodeBoolForKey: @"withRecognition"];
    __withRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAttributes"])
  {
    __withAttributes = [decoder decodeBoolForKey: @"withAttributes"];
    __withAttributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAlternateData"])
  {
    __withAlternateData = [decoder decodeBoolForKey: @"withAlternateData"];
    __withAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__withData_isset)
  {
    [encoder encodeBool: __withData forKey: @"withData"];
  }
  if (__withRecognition_isset)
  {
    [encoder encodeBool: __withRecognition forKey: @"withRecognition"];
  }
  if (__withAttributes_isset)
  {
    [encoder encodeBool: __withAttributes forKey: @"withAttributes"];
  }
  if (__withAlternateData_isset)
  {
    [encoder encodeBool: __withAlternateData forKey: @"withAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) withData {
  return __withData;
}

- (void) setWithData: (BOOL) withData {
  __withData = withData;
  __withData_isset = YES;
}

- (BOOL) withDataIsSet {
  return __withData_isset;
}

- (void) unsetWithData {
  __withData_isset = NO;
}

- (BOOL) withRecognition {
  return __withRecognition;
}

- (void) setWithRecognition: (BOOL) withRecognition {
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
}

- (BOOL) withRecognitionIsSet {
  return __withRecognition_isset;
}

- (void) unsetWithRecognition {
  __withRecognition_isset = NO;
}

- (BOOL) withAttributes {
  return __withAttributes;
}

- (void) setWithAttributes: (BOOL) withAttributes {
  __withAttributes = withAttributes;
  __withAttributes_isset = YES;
}

- (BOOL) withAttributesIsSet {
  return __withAttributes_isset;
}

- (void) unsetWithAttributes {
  __withAttributes_isset = NO;
}

- (BOOL) withAlternateData {
  return __withAlternateData;
}

- (void) setWithAlternateData: (BOOL) withAlternateData {
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
}

- (BOOL) withAlternateDataIsSet {
  return __withAlternateData_isset;
}

- (void) unsetWithAlternateData {
  __withAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAttributes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResource_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withData_isset) {
    [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withData];
    [outProtocol writeFieldEnd];
  }
  if (__withRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withAttributes_isset) {
    [outProtocol writeFieldBeginWithName: @"withAttributes" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withAttributes];
    [outProtocol writeFieldEnd];
  }
  if (__withAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResource_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",withData:"];
  [ms appendFormat: @"%i", __withData];
  [ms appendString: @",withRecognition:"];
  [ms appendFormat: @"%i", __withRecognition];
  [ms appendString: @",withAttributes:"];
  [ms appendFormat: @"%i", __withAttributes];
  [ms appendString: @",withAlternateData:"];
  [ms appendFormat: @"%i", __withAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResource_result : NSObject <NSCoding> {
  EDAMResource * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMResource * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMResource *) success;
- (void) setSuccess: (EDAMResource *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResource_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMResource *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMResource *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResource_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResource_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceApplicationData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceApplicationData_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceApplicationData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceApplicationData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceApplicationData_result : NSObject <NSCoding> {
  EDAMLazyMap * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMLazyMap * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMLazyMap *) success;
- (void) setSuccess: (EDAMLazyMap *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceApplicationData_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMLazyMap *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMLazyMap *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLazyMap *fieldValue = [[EDAMLazyMap alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceApplicationData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceApplicationData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, strong, getter=key, setter=setKey:) NSString * key;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) key;
- (void) setKey: (NSString *) key;
#endif
- (BOOL) keyIsSet;

@end

@implementation EDAMgetResourceApplicationDataEntry_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [__key release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSString *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceApplicationDataEntry_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) success;
- (void) setSuccess: (NSString *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceApplicationDataEntry_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSString *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSString *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceApplicationDataEntry_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMsetResourceApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;
  NSString * __value;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
  BOOL __value_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, strong, getter=key, setter=setKey:) NSString * key;
@property (nonatomic, strong, getter=value, setter=setValue:) NSString * value;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) key;
- (void) setKey: (NSString *) key;
#endif
- (BOOL) keyIsSet;

#if !__has_feature(objc_arc)
- (NSString *) value;
- (void) setValue: (NSString *) value;
#endif
- (BOOL) valueIsSet;

@end

@implementation EDAMsetResourceApplicationDataEntry_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  __value = [value retain_stub];
  __value_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [[decoder decodeObjectForKey: @"value"] retain_stub];
    __value_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
  if (__value_isset)
  {
    [encoder encodeObject: __value forKey: @"value"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [__key release_stub];
  [__value release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSString *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (NSString *) value {
  return [[__value retain_stub] autorelease_stub];
}

- (void) setValue: (NSString *) value {
  [value retain_stub];
  [__value release_stub];
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  [__value release_stub];
  __value = nil;
  __value_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"setResourceApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__value_isset) {
    if (__value != nil) {
      [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __value];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"setResourceApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @",value:"];
  [ms appendFormat: @"\"%@\"", __value];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMSetResourceApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMSetResourceApplicationDataEntry_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SetResourceApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SetResourceApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMunsetResourceApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, strong, getter=key, setter=setKey:) NSString * key;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) key;
- (void) setKey: (NSString *) key;
#endif
- (BOOL) keyIsSet;

@end

@implementation EDAMunsetResourceApplicationDataEntry_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __key = [key retain_stub];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain_stub];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [__key release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain_stub] autorelease_stub];
}

- (void) setKey: (NSString *) key {
  [key retain_stub];
  [__key release_stub];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release_stub];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"unsetResourceApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"unsetResourceApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUnsetResourceApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUnsetResourceApplicationDataEntry_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UnsetResourceApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UnsetResourceApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateResource_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMResource * __resource;

  BOOL __authenticationToken_isset;
  BOOL __resource_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=resource, setter=setResource:) EDAMResource * resource;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken resource: (EDAMResource *) resource;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMResource *) resource;
- (void) setResource: (EDAMResource *) resource;
#endif
- (BOOL) resourceIsSet;

@end

@implementation EDAMupdateResource_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken resource: (EDAMResource *) resource
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __resource = [resource retain_stub];
  __resource_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"resource"])
  {
    __resource = [[decoder decodeObjectForKey: @"resource"] retain_stub];
    __resource_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__resource_isset)
  {
    [encoder encodeObject: __resource forKey: @"resource"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__resource release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMResource *) resource {
  return [[__resource retain_stub] autorelease_stub];
}

- (void) setResource: (EDAMResource *) resource {
  [resource retain_stub];
  [__resource release_stub];
  __resource = resource;
  __resource_isset = YES;
}

- (BOOL) resourceIsSet {
  return __resource_isset;
}

- (void) unsetResource {
  [__resource release_stub];
  __resource = nil;
  __resource_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setResource: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateResource_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__resource_isset) {
    if (__resource != nil) {
      [outProtocol writeFieldBeginWithName: @"resource" type: TType_STRUCT fieldID: 2];
      [__resource write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateResource_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",resource:"];
  [ms appendFormat: @"%@", __resource];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateResource_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateResource_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateResource_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateResource_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceData_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceData_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSData *) success;
- (void) setSuccess: (NSData *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceData_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSData *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSData *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceByHash_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  NSData * __contentHash;
  BOOL __withData;
  BOOL __withRecognition;
  BOOL __withAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __contentHash_isset;
  BOOL __withData_isset;
  BOOL __withRecognition_isset;
  BOOL __withAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, strong, getter=contentHash, setter=setContentHash:) NSData * contentHash;
@property (nonatomic, getter=withData, setter=setWithData:) BOOL withData;
@property (nonatomic, getter=withRecognition, setter=setWithRecognition:) BOOL withRecognition;
@property (nonatomic, getter=withAlternateData, setter=setWithAlternateData:) BOOL withAlternateData;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
#endif
- (BOOL) noteGuidIsSet;

#if !__has_feature(objc_arc)
- (NSData *) contentHash;
- (void) setContentHash: (NSData *) contentHash;
#endif
- (BOOL) contentHashIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withData;
- (void) setWithData: (BOOL) withData;
#endif
- (BOOL) withDataIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withRecognition;
- (void) setWithRecognition: (BOOL) withRecognition;
#endif
- (BOOL) withRecognitionIsSet;

#if !__has_feature(objc_arc)
- (BOOL) withAlternateData;
- (void) setWithAlternateData: (BOOL) withAlternateData;
#endif
- (BOOL) withAlternateDataIsSet;

@end

@implementation EDAMgetResourceByHash_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain_stub];
  __noteGuid_isset = YES;
  __contentHash = [contentHash retain_stub];
  __contentHash_isset = YES;
  __withData = withData;
  __withData_isset = YES;
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain_stub];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"contentHash"])
  {
    __contentHash = [[decoder decodeObjectForKey: @"contentHash"] retain_stub];
    __contentHash_isset = YES;
  }
  if ([decoder containsValueForKey: @"withData"])
  {
    __withData = [decoder decodeBoolForKey: @"withData"];
    __withData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withRecognition"])
  {
    __withRecognition = [decoder decodeBoolForKey: @"withRecognition"];
    __withRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAlternateData"])
  {
    __withAlternateData = [decoder decodeBoolForKey: @"withAlternateData"];
    __withAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__contentHash_isset)
  {
    [encoder encodeObject: __contentHash forKey: @"contentHash"];
  }
  if (__withData_isset)
  {
    [encoder encodeBool: __withData forKey: @"withData"];
  }
  if (__withRecognition_isset)
  {
    [encoder encodeBool: __withRecognition forKey: @"withRecognition"];
  }
  if (__withAlternateData_isset)
  {
    [encoder encodeBool: __withAlternateData forKey: @"withAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__noteGuid release_stub];
  [__contentHash release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain_stub] autorelease_stub];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain_stub];
  [__noteGuid release_stub];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release_stub];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (NSData *) contentHash {
  return [[__contentHash retain_stub] autorelease_stub];
}

- (void) setContentHash: (NSData *) contentHash {
  [contentHash retain_stub];
  [__contentHash release_stub];
  __contentHash = contentHash;
  __contentHash_isset = YES;
}

- (BOOL) contentHashIsSet {
  return __contentHash_isset;
}

- (void) unsetContentHash {
  [__contentHash release_stub];
  __contentHash = nil;
  __contentHash_isset = NO;
}

- (BOOL) withData {
  return __withData;
}

- (void) setWithData: (BOOL) withData {
  __withData = withData;
  __withData_isset = YES;
}

- (BOOL) withDataIsSet {
  return __withData_isset;
}

- (void) unsetWithData {
  __withData_isset = NO;
}

- (BOOL) withRecognition {
  return __withRecognition;
}

- (void) setWithRecognition: (BOOL) withRecognition {
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
}

- (BOOL) withRecognitionIsSet {
  return __withRecognition_isset;
}

- (void) unsetWithRecognition {
  __withRecognition_isset = NO;
}

- (BOOL) withAlternateData {
  return __withAlternateData;
}

- (void) setWithAlternateData: (BOOL) withAlternateData {
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
}

- (BOOL) withAlternateDataIsSet {
  return __withAlternateData_isset;
}

- (void) unsetWithAlternateData {
  __withAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setContentHash: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceByHash_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__contentHash_isset) {
    if (__contentHash != nil) {
      [outProtocol writeFieldBeginWithName: @"contentHash" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __contentHash];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withData_isset) {
    [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withData];
    [outProtocol writeFieldEnd];
  }
  if (__withRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceByHash_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",contentHash:"];
  [ms appendFormat: @"\"%@\"", __contentHash];
  [ms appendString: @",withData:"];
  [ms appendFormat: @"%i", __withData];
  [ms appendString: @",withRecognition:"];
  [ms appendFormat: @"%i", __withRecognition];
  [ms appendString: @",withAlternateData:"];
  [ms appendFormat: @"%i", __withAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceByHash_result : NSObject <NSCoding> {
  EDAMResource * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMResource * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMResource *) success;
- (void) setSuccess: (EDAMResource *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceByHash_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMResource *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMResource *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceByHash_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceByHash_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceRecognition_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceRecognition_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceRecognition_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceRecognition_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceRecognition_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSData *) success;
- (void) setSuccess: (NSData *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceRecognition_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSData *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSData *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceRecognition_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceRecognition_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceAlternateData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceAlternateData_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceAlternateData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceAlternateData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceAlternateData_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSData *) success;
- (void) setSuccess: (NSData *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceAlternateData_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (NSData *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSData *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceAlternateData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceAlternateData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceAttributes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceAttributes_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceAttributes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceAttributes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceAttributes_result : NSObject <NSCoding> {
  EDAMResourceAttributes * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMResourceAttributes * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMResourceAttributes *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMResourceAttributes *) success;
- (void) setSuccess: (EDAMResourceAttributes *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceAttributes_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMResourceAttributes *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMResourceAttributes *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMResourceAttributes *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResourceAttributes *fieldValue = [[EDAMResourceAttributes alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceAttributes_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceAttributes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetPublicNotebook_args : NSObject <NSCoding> {
  EDAMUserID __userId;
  NSString * __publicUri;

  BOOL __userId_isset;
  BOOL __publicUri_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=userId, setter=setUserId:) EDAMUserID userId;
@property (nonatomic, strong, getter=publicUri, setter=setPublicUri:) NSString * publicUri;
#endif

- (id) init;
- (id) initWithUserId: (EDAMUserID) userId publicUri: (NSString *) publicUri;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMUserID) userId;
- (void) setUserId: (EDAMUserID) userId;
#endif
- (BOOL) userIdIsSet;

#if !__has_feature(objc_arc)
- (NSString *) publicUri;
- (void) setPublicUri: (NSString *) publicUri;
#endif
- (BOOL) publicUriIsSet;

@end

@implementation EDAMgetPublicNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithUserId: (EDAMUserID) userId publicUri: (NSString *) publicUri
{
  self = [super init];
  __userId = userId;
  __userId_isset = YES;
  __publicUri = [publicUri retain_stub];
  __publicUri_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userId"])
  {
    __userId = [decoder decodeInt32ForKey: @"userId"];
    __userId_isset = YES;
  }
  if ([decoder containsValueForKey: @"publicUri"])
  {
    __publicUri = [[decoder decodeObjectForKey: @"publicUri"] retain_stub];
    __publicUri_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userId_isset)
  {
    [encoder encodeInt32: __userId forKey: @"userId"];
  }
  if (__publicUri_isset)
  {
    [encoder encodeObject: __publicUri forKey: @"publicUri"];
  }
}

- (void) dealloc
{
  [__publicUri release_stub];
  [super dealloc_stub];
}

- (int32_t) userId {
  return __userId;
}

- (void) setUserId: (int32_t) userId {
  __userId = userId;
  __userId_isset = YES;
}

- (BOOL) userIdIsSet {
  return __userId_isset;
}

- (void) unsetUserId {
  __userId_isset = NO;
}

- (NSString *) publicUri {
  return [[__publicUri retain_stub] autorelease_stub];
}

- (void) setPublicUri: (NSString *) publicUri {
  [publicUri retain_stub];
  [__publicUri release_stub];
  __publicUri = publicUri;
  __publicUri_isset = YES;
}

- (BOOL) publicUriIsSet {
  return __publicUri_isset;
}

- (void) unsetPublicUri {
  [__publicUri release_stub];
  __publicUri = nil;
  __publicUri_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUserId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPublicUri: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getPublicNotebook_args"];
  if (__userId_isset) {
    [outProtocol writeFieldBeginWithName: @"userId" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __userId];
    [outProtocol writeFieldEnd];
  }
  if (__publicUri_isset) {
    if (__publicUri != nil) {
      [outProtocol writeFieldBeginWithName: @"publicUri" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __publicUri];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getPublicNotebook_args("];
  [ms appendString: @"userId:"];
  [ms appendFormat: @"%i", __userId];
  [ms appendString: @",publicUri:"];
  [ms appendFormat: @"\"%@\"", __publicUri];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetPublicNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMNotebook *) success systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetPublicNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMNotebook *) success systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMNotebook *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetPublicNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 1];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetPublicNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateSharedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSharedNotebook * __sharedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __sharedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=sharedNotebook, setter=setSharedNotebook:) EDAMSharedNotebook * sharedNotebook;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMSharedNotebook *) sharedNotebook;
- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook;
#endif
- (BOOL) sharedNotebookIsSet;

@end

@implementation EDAMcreateSharedNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __sharedNotebook = [sharedNotebook retain_stub];
  __sharedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"sharedNotebook"])
  {
    __sharedNotebook = [[decoder decodeObjectForKey: @"sharedNotebook"] retain_stub];
    __sharedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__sharedNotebook_isset)
  {
    [encoder encodeObject: __sharedNotebook forKey: @"sharedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__sharedNotebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSharedNotebook *) sharedNotebook {
  return [[__sharedNotebook retain_stub] autorelease_stub];
}

- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook {
  [sharedNotebook retain_stub];
  [__sharedNotebook release_stub];
  __sharedNotebook = sharedNotebook;
  __sharedNotebook_isset = YES;
}

- (BOOL) sharedNotebookIsSet {
  return __sharedNotebook_isset;
}

- (void) unsetSharedNotebook {
  [__sharedNotebook release_stub];
  __sharedNotebook = nil;
  __sharedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSharedNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createSharedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sharedNotebook_isset) {
    if (__sharedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
      [__sharedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createSharedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",sharedNotebook:"];
  [ms appendFormat: @"%@", __sharedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateSharedNotebook_result : NSObject <NSCoding> {
  EDAMSharedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSharedNotebook * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSharedNotebook *) success;
- (void) setSuccess: (EDAMSharedNotebook *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateSharedNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMSharedNotebook *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSharedNotebook *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateSharedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateSharedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateSharedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSharedNotebook * __sharedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __sharedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=sharedNotebook, setter=setSharedNotebook:) EDAMSharedNotebook * sharedNotebook;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMSharedNotebook *) sharedNotebook;
- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook;
#endif
- (BOOL) sharedNotebookIsSet;

@end

@implementation EDAMupdateSharedNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __sharedNotebook = [sharedNotebook retain_stub];
  __sharedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"sharedNotebook"])
  {
    __sharedNotebook = [[decoder decodeObjectForKey: @"sharedNotebook"] retain_stub];
    __sharedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__sharedNotebook_isset)
  {
    [encoder encodeObject: __sharedNotebook forKey: @"sharedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__sharedNotebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSharedNotebook *) sharedNotebook {
  return [[__sharedNotebook retain_stub] autorelease_stub];
}

- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook {
  [sharedNotebook retain_stub];
  [__sharedNotebook release_stub];
  __sharedNotebook = sharedNotebook;
  __sharedNotebook_isset = YES;
}

- (BOOL) sharedNotebookIsSet {
  return __sharedNotebook_isset;
}

- (void) unsetSharedNotebook {
  [__sharedNotebook release_stub];
  __sharedNotebook = nil;
  __sharedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSharedNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateSharedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sharedNotebook_isset) {
    if (__sharedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
      [__sharedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateSharedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",sharedNotebook:"];
  [ms appendFormat: @"%@", __sharedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateSharedNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMUpdateSharedNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateSharedNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateSharedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMsendMessageToSharedNotebookMembers_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __notebookGuid;
  NSString * __messageText;
  NSMutableArray * __recipients;

  BOOL __authenticationToken_isset;
  BOOL __notebookGuid_isset;
  BOOL __messageText_isset;
  BOOL __recipients_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=notebookGuid, setter=setNotebookGuid:) EDAMGuid notebookGuid;
@property (nonatomic, strong, getter=messageText, setter=setMessageText:) NSString * messageText;
@property (nonatomic, strong, getter=recipients, setter=setRecipients:) NSMutableArray * recipients;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid messageText: (NSString *) messageText recipients: (NSMutableArray *) recipients;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) notebookGuid;
- (void) setNotebookGuid: (EDAMGuid) notebookGuid;
#endif
- (BOOL) notebookGuidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) messageText;
- (void) setMessageText: (NSString *) messageText;
#endif
- (BOOL) messageTextIsSet;

#if !__has_feature(objc_arc)
- (NSMutableArray *) recipients;
- (void) setRecipients: (NSMutableArray *) recipients;
#endif
- (BOOL) recipientsIsSet;

@end

@implementation EDAMsendMessageToSharedNotebookMembers_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid messageText: (NSString *) messageText recipients: (NSMutableArray *) recipients
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __notebookGuid = [notebookGuid retain_stub];
  __notebookGuid_isset = YES;
  __messageText = [messageText retain_stub];
  __messageText_isset = YES;
  __recipients = [recipients retain_stub];
  __recipients_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain_stub];
    __notebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"messageText"])
  {
    __messageText = [[decoder decodeObjectForKey: @"messageText"] retain_stub];
    __messageText_isset = YES;
  }
  if ([decoder containsValueForKey: @"recipients"])
  {
    __recipients = [[decoder decodeObjectForKey: @"recipients"] retain_stub];
    __recipients_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
  if (__messageText_isset)
  {
    [encoder encodeObject: __messageText forKey: @"messageText"];
  }
  if (__recipients_isset)
  {
    [encoder encodeObject: __recipients forKey: @"recipients"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__notebookGuid release_stub];
  [__messageText release_stub];
  [__recipients release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain_stub] autorelease_stub];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain_stub];
  [__notebookGuid release_stub];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release_stub];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (NSString *) messageText {
  return [[__messageText retain_stub] autorelease_stub];
}

- (void) setMessageText: (NSString *) messageText {
  [messageText retain_stub];
  [__messageText release_stub];
  __messageText = messageText;
  __messageText_isset = YES;
}

- (BOOL) messageTextIsSet {
  return __messageText_isset;
}

- (void) unsetMessageText {
  [__messageText release_stub];
  __messageText = nil;
  __messageText_isset = NO;
}

- (NSMutableArray *) recipients {
  return [[__recipients retain_stub] autorelease_stub];
}

- (void) setRecipients: (NSMutableArray *) recipients {
  [recipients retain_stub];
  [__recipients release_stub];
  __recipients = recipients;
  __recipients_isset = YES;
}

- (BOOL) recipientsIsSet {
  return __recipients_isset;
}

- (void) unsetRecipients {
  [__recipients release_stub];
  __recipients = nil;
  __recipients_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessageText: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size172;
          [inProtocol readListBeginReturningElementType: NULL size: &_size172];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size172];
          int _i173;
          for (_i173 = 0; _i173 < _size172; ++_i173)
          {
            NSString * _elem174 = [inProtocol readString];
            [fieldValue addObject: _elem174];
          }
          [inProtocol readListEnd];
          [self setRecipients: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"sendMessageToSharedNotebookMembers_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__messageText_isset) {
    if (__messageText != nil) {
      [outProtocol writeFieldBeginWithName: @"messageText" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __messageText];
      [outProtocol writeFieldEnd];
    }
  }
  if (__recipients_isset) {
    if (__recipients != nil) {
      [outProtocol writeFieldBeginWithName: @"recipients" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__recipients count]];
        int i176;
        for (i176 = 0; i176 < [__recipients count]; i176++)
        {
          [outProtocol writeString: [__recipients objectAtIndex: i176]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"sendMessageToSharedNotebookMembers_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @",messageText:"];
  [ms appendFormat: @"\"%@\"", __messageText];
  [ms appendString: @",recipients:"];
  [ms appendFormat: @"%@", __recipients];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMSendMessageToSharedNotebookMembers_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMSendMessageToSharedNotebookMembers_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SendMessageToSharedNotebookMembers_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SendMessageToSharedNotebookMembers_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistSharedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistSharedNotebooks_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listSharedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listSharedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListSharedNotebooks_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListSharedNotebooks_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size177;
          [inProtocol readListBeginReturningElementType: NULL size: &_size177];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size177];
          int _i178;
          for (_i178 = 0; _i178 < _size177; ++_i178)
          {
            EDAMSharedNotebook *_elem179 = [[EDAMSharedNotebook alloc] init];
            [_elem179 read: inProtocol];
            [fieldValue addObject: _elem179];
            [_elem179 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListSharedNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i181;
        for (i181 = 0; i181 < [__success count]; i181++)
        {
          [[__success objectAtIndex: i181] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListSharedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeSharedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  NSMutableArray * __sharedNotebookIds;

  BOOL __authenticationToken_isset;
  BOOL __sharedNotebookIds_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=sharedNotebookIds, setter=setSharedNotebookIds:) NSMutableArray * sharedNotebookIds;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebookIds: (NSMutableArray *) sharedNotebookIds;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (NSMutableArray *) sharedNotebookIds;
- (void) setSharedNotebookIds: (NSMutableArray *) sharedNotebookIds;
#endif
- (BOOL) sharedNotebookIdsIsSet;

@end

@implementation EDAMexpungeSharedNotebooks_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebookIds: (NSMutableArray *) sharedNotebookIds
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __sharedNotebookIds = [sharedNotebookIds retain_stub];
  __sharedNotebookIds_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"sharedNotebookIds"])
  {
    __sharedNotebookIds = [[decoder decodeObjectForKey: @"sharedNotebookIds"] retain_stub];
    __sharedNotebookIds_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__sharedNotebookIds_isset)
  {
    [encoder encodeObject: __sharedNotebookIds forKey: @"sharedNotebookIds"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__sharedNotebookIds release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSMutableArray *) sharedNotebookIds {
  return [[__sharedNotebookIds retain_stub] autorelease_stub];
}

- (void) setSharedNotebookIds: (NSMutableArray *) sharedNotebookIds {
  [sharedNotebookIds retain_stub];
  [__sharedNotebookIds release_stub];
  __sharedNotebookIds = sharedNotebookIds;
  __sharedNotebookIds_isset = YES;
}

- (BOOL) sharedNotebookIdsIsSet {
  return __sharedNotebookIds_isset;
}

- (void) unsetSharedNotebookIds {
  [__sharedNotebookIds release_stub];
  __sharedNotebookIds = nil;
  __sharedNotebookIds_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size182;
          [inProtocol readListBeginReturningElementType: NULL size: &_size182];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size182];
          int _i183;
          for (_i183 = 0; _i183 < _size182; ++_i183)
          {
            int64_t _elem184 = [inProtocol readI64];
            [fieldValue addObject: [NSNumber numberWithLongLong: _elem184]];
          }
          [inProtocol readListEnd];
          [self setSharedNotebookIds: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeSharedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sharedNotebookIds_isset) {
    if (__sharedNotebookIds != nil) {
      [outProtocol writeFieldBeginWithName: @"sharedNotebookIds" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_I64 size: [__sharedNotebookIds count]];
        int i186;
        for (i186 = 0; i186 < [__sharedNotebookIds count]; i186++)
        {
          [outProtocol writeI64: [[__sharedNotebookIds objectAtIndex: i186] longLongValue]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeSharedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",sharedNotebookIds:"];
  [ms appendFormat: @"%@", __sharedNotebookIds];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeSharedNotebooks_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMExpungeSharedNotebooks_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeSharedNotebooks_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeSharedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;
#endif
- (BOOL) linkedNotebookIsSet;

@end

@implementation EDAMcreateLinkedNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain_stub];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain_stub];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__linkedNotebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain_stub] autorelease_stub];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain_stub];
  [__linkedNotebook release_stub];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release_stub];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateLinkedNotebook_result : NSObject <NSCoding> {
  EDAMLinkedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMLinkedNotebook * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMLinkedNotebook *) success;
- (void) setSuccess: (EDAMLinkedNotebook *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateLinkedNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMLinkedNotebook *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMLinkedNotebook *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateLinkedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;
#endif
- (BOOL) linkedNotebookIsSet;

@end

@implementation EDAMupdateLinkedNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain_stub];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain_stub];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__linkedNotebook release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain_stub] autorelease_stub];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain_stub];
  [__linkedNotebook release_stub];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release_stub];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateLinkedNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMUpdateLinkedNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateLinkedNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistLinkedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistLinkedNotebooks_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listLinkedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listLinkedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListLinkedNotebooks_result : NSObject <NSCoding> {
  NSMutableArray * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListLinkedNotebooks_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size187;
          [inProtocol readListBeginReturningElementType: NULL size: &_size187];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size187];
          int _i188;
          for (_i188 = 0; _i188 < _size187; ++_i188)
          {
            EDAMLinkedNotebook *_elem189 = [[EDAMLinkedNotebook alloc] init];
            [_elem189 read: inProtocol];
            [fieldValue addObject: _elem189];
            [_elem189 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListLinkedNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i191;
        for (i191 = 0; i191 < [__success count]; i191++)
        {
          [[__success objectAtIndex: i191] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListLinkedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeLinkedNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeLinkedNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (int32_t) success;
- (void) setSuccess: (int32_t) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMExpungeLinkedNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeLinkedNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMauthenticateToSharedNotebook_args : NSObject <NSCoding> {
  NSString * __shareKey;
  NSString * __authenticationToken;

  BOOL __shareKey_isset;
  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=shareKey, setter=setShareKey:) NSString * shareKey;
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithShareKey: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) shareKey;
- (void) setShareKey: (NSString *) shareKey;
#endif
- (BOOL) shareKeyIsSet;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMauthenticateToSharedNotebook_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithShareKey: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __shareKey = [shareKey retain_stub];
  __shareKey_isset = YES;
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"shareKey"])
  {
    __shareKey = [[decoder decodeObjectForKey: @"shareKey"] retain_stub];
    __shareKey_isset = YES;
  }
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__shareKey_isset)
  {
    [encoder encodeObject: __shareKey forKey: @"shareKey"];
  }
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__shareKey release_stub];
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) shareKey {
  return [[__shareKey retain_stub] autorelease_stub];
}

- (void) setShareKey: (NSString *) shareKey {
  [shareKey retain_stub];
  [__shareKey release_stub];
  __shareKey = shareKey;
  __shareKey_isset = YES;
}

- (BOOL) shareKeyIsSet {
  return __shareKey_isset;
}

- (void) unsetShareKey {
  [__shareKey release_stub];
  __shareKey = nil;
  __shareKey_isset = NO;
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setShareKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNotebook_args"];
  if (__shareKey_isset) {
    if (__shareKey != nil) {
      [outProtocol writeFieldBeginWithName: @"shareKey" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __shareKey];
      [outProtocol writeFieldEnd];
    }
  }
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"authenticateToSharedNotebook_args("];
  [ms appendString: @"shareKey:"];
  [ms appendFormat: @"\"%@\"", __shareKey];
  [ms appendString: @",authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMAuthenticateToSharedNotebook_result : NSObject <NSCoding> {
  EDAMAuthenticationResult * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMAuthenticationResult * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMAuthenticationResult *) success;
- (void) setSuccess: (EDAMAuthenticationResult *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMAuthenticateToSharedNotebook_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMAuthenticationResult *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMAuthenticationResult *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMAuthenticationResult *fieldValue = [[EDAMAuthenticationResult alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AuthenticateToSharedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AuthenticateToSharedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSharedNotebookByAuth_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMgetSharedNotebookByAuth_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSharedNotebookByAuth_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSharedNotebookByAuth_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSharedNotebookByAuth_result : NSObject <NSCoding> {
  EDAMSharedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMSharedNotebook * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMSharedNotebook *) success;
- (void) setSuccess: (EDAMSharedNotebook *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetSharedNotebookByAuth_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMSharedNotebook *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMSharedNotebook *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSharedNotebookByAuth_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSharedNotebookByAuth_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMemailNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteEmailParameters * __parameters;

  BOOL __authenticationToken_isset;
  BOOL __parameters_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=parameters, setter=setParameters:) EDAMNoteEmailParameters * parameters;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMNoteEmailParameters *) parameters;
- (void) setParameters: (EDAMNoteEmailParameters *) parameters;
#endif
- (BOOL) parametersIsSet;

@end

@implementation EDAMemailNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __parameters = [parameters retain_stub];
  __parameters_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"parameters"])
  {
    __parameters = [[decoder decodeObjectForKey: @"parameters"] retain_stub];
    __parameters_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__parameters_isset)
  {
    [encoder encodeObject: __parameters forKey: @"parameters"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__parameters release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteEmailParameters *) parameters {
  return [[__parameters retain_stub] autorelease_stub];
}

- (void) setParameters: (EDAMNoteEmailParameters *) parameters {
  [parameters retain_stub];
  [__parameters release_stub];
  __parameters = parameters;
  __parameters_isset = YES;
}

- (BOOL) parametersIsSet {
  return __parameters_isset;
}

- (void) unsetParameters {
  [__parameters release_stub];
  __parameters = nil;
  __parameters_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteEmailParameters *fieldValue = [[EDAMNoteEmailParameters alloc] init];
          [fieldValue read: inProtocol];
          [self setParameters: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"emailNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__parameters_isset) {
    if (__parameters != nil) {
      [outProtocol writeFieldBeginWithName: @"parameters" type: TType_STRUCT fieldID: 2];
      [__parameters write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"emailNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",parameters:"];
  [ms appendFormat: @"%@", __parameters];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMEmailNote_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMEmailNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"EmailNote_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"EmailNote_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMshareNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMshareNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"shareNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"shareNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMShareNote_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) success;
- (void) setSuccess: (NSString *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMShareNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (NSString *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSString *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ShareNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ShareNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMstopSharingNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
#endif
- (BOOL) guidIsSet;

@end

@implementation EDAMstopSharingNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __guid = [guid retain_stub];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__guid release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"stopSharingNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"stopSharingNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMStopSharingNote_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMStopSharingNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"StopSharingNote_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"StopSharingNote_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMauthenticateToSharedNote_args : NSObject <NSCoding> {
  NSString * __guid;
  NSString * __noteKey;

  BOOL __guid_isset;
  BOOL __noteKey_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=guid, setter=setGuid:) NSString * guid;
@property (nonatomic, strong, getter=noteKey, setter=setNoteKey:) NSString * noteKey;
#endif

- (id) init;
- (id) initWithGuid: (NSString *) guid noteKey: (NSString *) noteKey;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) guid;
- (void) setGuid: (NSString *) guid;
#endif
- (BOOL) guidIsSet;

#if !__has_feature(objc_arc)
- (NSString *) noteKey;
- (void) setNoteKey: (NSString *) noteKey;
#endif
- (BOOL) noteKeyIsSet;

@end

@implementation EDAMauthenticateToSharedNote_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithGuid: (NSString *) guid noteKey: (NSString *) noteKey
{
  self = [super init];
  __guid = [guid retain_stub];
  __guid_isset = YES;
  __noteKey = [noteKey retain_stub];
  __noteKey_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain_stub];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteKey"])
  {
    __noteKey = [[decoder decodeObjectForKey: @"noteKey"] retain_stub];
    __noteKey_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__noteKey_isset)
  {
    [encoder encodeObject: __noteKey forKey: @"noteKey"];
  }
}

- (void) dealloc
{
  [__guid release_stub];
  [__noteKey release_stub];
  [super dealloc_stub];
}

- (NSString *) guid {
  return [[__guid retain_stub] autorelease_stub];
}

- (void) setGuid: (NSString *) guid {
  [guid retain_stub];
  [__guid release_stub];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release_stub];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) noteKey {
  return [[__noteKey retain_stub] autorelease_stub];
}

- (void) setNoteKey: (NSString *) noteKey {
  [noteKey retain_stub];
  [__noteKey release_stub];
  __noteKey = noteKey;
  __noteKey_isset = YES;
}

- (BOOL) noteKeyIsSet {
  return __noteKey_isset;
}

- (void) unsetNoteKey {
  [__noteKey release_stub];
  __noteKey = nil;
  __noteKey_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNote_args"];
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteKey_isset) {
    if (__noteKey != nil) {
      [outProtocol writeFieldBeginWithName: @"noteKey" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteKey];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"authenticateToSharedNote_args("];
  [ms appendString: @"guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",noteKey:"];
  [ms appendFormat: @"\"%@\"", __noteKey];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMAuthenticateToSharedNote_result : NSObject <NSCoding> {
  EDAMAuthenticationResult * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMAuthenticationResult * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMAuthenticationResult *) success;
- (void) setSuccess: (EDAMAuthenticationResult *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMAuthenticateToSharedNote_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__notFoundException release_stub];
  [__systemException release_stub];
  [super dealloc_stub];
}

- (EDAMAuthenticationResult *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMAuthenticationResult *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMAuthenticationResult *fieldValue = [[EDAMAuthenticationResult alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AuthenticateToSharedNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AuthenticateToSharedNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindRelated_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMRelatedQuery * __query;
  EDAMRelatedResultSpec * __resultSpec;

  BOOL __authenticationToken_isset;
  BOOL __query_isset;
  BOOL __resultSpec_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, strong, getter=query, setter=setQuery:) EDAMRelatedQuery * query;
@property (nonatomic, strong, getter=resultSpec, setter=setResultSpec:) EDAMRelatedResultSpec * resultSpec;
#endif

- (id) init;
- (id) initWithAuthenticationToken: (NSString *) authenticationToken query: (EDAMRelatedQuery *) query resultSpec: (EDAMRelatedResultSpec *) resultSpec;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
#endif
- (BOOL) authenticationTokenIsSet;

#if !__has_feature(objc_arc)
- (EDAMRelatedQuery *) query;
- (void) setQuery: (EDAMRelatedQuery *) query;
#endif
- (BOOL) queryIsSet;

#if !__has_feature(objc_arc)
- (EDAMRelatedResultSpec *) resultSpec;
- (void) setResultSpec: (EDAMRelatedResultSpec *) resultSpec;
#endif
- (BOOL) resultSpecIsSet;

@end

@implementation EDAMfindRelated_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken query: (EDAMRelatedQuery *) query resultSpec: (EDAMRelatedResultSpec *) resultSpec
{
  self = [super init];
  __authenticationToken = [authenticationToken retain_stub];
  __authenticationToken_isset = YES;
  __query = [query retain_stub];
  __query_isset = YES;
  __resultSpec = [resultSpec retain_stub];
  __resultSpec_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain_stub];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"query"])
  {
    __query = [[decoder decodeObjectForKey: @"query"] retain_stub];
    __query_isset = YES;
  }
  if ([decoder containsValueForKey: @"resultSpec"])
  {
    __resultSpec = [[decoder decodeObjectForKey: @"resultSpec"] retain_stub];
    __resultSpec_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__query_isset)
  {
    [encoder encodeObject: __query forKey: @"query"];
  }
  if (__resultSpec_isset)
  {
    [encoder encodeObject: __resultSpec forKey: @"resultSpec"];
  }
}

- (void) dealloc
{
  [__authenticationToken release_stub];
  [__query release_stub];
  [__resultSpec release_stub];
  [super dealloc_stub];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain_stub] autorelease_stub];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain_stub];
  [__authenticationToken release_stub];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release_stub];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMRelatedQuery *) query {
  return [[__query retain_stub] autorelease_stub];
}

- (void) setQuery: (EDAMRelatedQuery *) query {
  [query retain_stub];
  [__query release_stub];
  __query = query;
  __query_isset = YES;
}

- (BOOL) queryIsSet {
  return __query_isset;
}

- (void) unsetQuery {
  [__query release_stub];
  __query = nil;
  __query_isset = NO;
}

- (EDAMRelatedResultSpec *) resultSpec {
  return [[__resultSpec retain_stub] autorelease_stub];
}

- (void) setResultSpec: (EDAMRelatedResultSpec *) resultSpec {
  [resultSpec retain_stub];
  [__resultSpec release_stub];
  __resultSpec = resultSpec;
  __resultSpec_isset = YES;
}

- (BOOL) resultSpecIsSet {
  return __resultSpec_isset;
}

- (void) unsetResultSpec {
  [__resultSpec release_stub];
  __resultSpec = nil;
  __resultSpec_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMRelatedQuery *fieldValue = [[EDAMRelatedQuery alloc] init];
          [fieldValue read: inProtocol];
          [self setQuery: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMRelatedResultSpec *fieldValue = [[EDAMRelatedResultSpec alloc] init];
          [fieldValue read: inProtocol];
          [self setResultSpec: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findRelated_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__query_isset) {
    if (__query != nil) {
      [outProtocol writeFieldBeginWithName: @"query" type: TType_STRUCT fieldID: 2];
      [__query write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__resultSpec_isset) {
    if (__resultSpec != nil) {
      [outProtocol writeFieldBeginWithName: @"resultSpec" type: TType_STRUCT fieldID: 3];
      [__resultSpec write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findRelated_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",query:"];
  [ms appendFormat: @"%@", __query];
  [ms appendString: @",resultSpec:"];
  [ms appendFormat: @"%@", __resultSpec];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindRelated_result : NSObject <NSCoding> {
  EDAMRelatedResult * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, strong, getter=success, setter=setSuccess:) EDAMRelatedResult * success;
@property (nonatomic, strong, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, strong, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, strong, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) init;
- (id) initWithSuccess: (EDAMRelatedResult *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (EDAMRelatedResult *) success;
- (void) setSuccess: (EDAMRelatedResult *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
#endif
- (BOOL) userExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
#endif
- (BOOL) systemExceptionIsSet;

#if !__has_feature(objc_arc)
- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
#endif
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMFindRelated_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (EDAMRelatedResult *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __userException = [userException retain_stub];
  __userException_isset = YES;
  __systemException = [systemException retain_stub];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain_stub];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain_stub];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain_stub];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain_stub];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__userException release_stub];
  [__systemException release_stub];
  [__notFoundException release_stub];
  [super dealloc_stub];
}

- (EDAMRelatedResult *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (EDAMRelatedResult *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain_stub] autorelease_stub];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain_stub];
  [__userException release_stub];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release_stub];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain_stub] autorelease_stub];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain_stub];
  [__systemException release_stub];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release_stub];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain_stub] autorelease_stub];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain_stub];
  [__notFoundException release_stub];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release_stub];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMRelatedResult *fieldValue = [[EDAMRelatedResult alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindRelated_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindRelated_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteStoreClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) dealloc
{
  [inProtocol release_stub];
  [outProtocol release_stub];
  [super dealloc_stub];
}

- (void) send_getSyncState: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getSyncState" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSyncState_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncState *) recv_getSyncState
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSyncState_result * result = [[[EDAMGetSyncState_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSyncState failed: unknown result"];
}

- (EDAMSyncState *) getSyncState: (NSString *) authenticationToken
{
  [self send_getSyncState : authenticationToken];
  return [self recv_getSyncState];
}

- (void) send_getSyncStateWithMetrics: (NSString *) authenticationToken clientMetrics: (EDAMClientUsageMetrics *) clientMetrics
{
  [outProtocol writeMessageBeginWithName: @"getSyncStateWithMetrics" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSyncStateWithMetrics_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (clientMetrics != nil)  {
    [outProtocol writeFieldBeginWithName: @"clientMetrics" type: TType_STRUCT fieldID: 2];
    [clientMetrics write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncState *) recv_getSyncStateWithMetrics
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSyncStateWithMetrics_result * result = [[[EDAMGetSyncStateWithMetrics_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSyncStateWithMetrics failed: unknown result"];
}

- (EDAMSyncState *) getSyncStateWithMetrics: (NSString *) authenticationToken clientMetrics: (EDAMClientUsageMetrics *) clientMetrics
{
  [self send_getSyncStateWithMetrics : authenticationToken clientMetrics: clientMetrics];
  return [self recv_getSyncStateWithMetrics];
}

- (void) send_getSyncChunk: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  [outProtocol writeMessageBeginWithName: @"getSyncChunk" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSyncChunk_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: afterUSN];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: maxEntries];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: fullSyncOnly];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncChunk *) recv_getSyncChunk
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSyncChunk_result * result = [[[EDAMGetSyncChunk_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSyncChunk failed: unknown result"];
}

- (EDAMSyncChunk *) getSyncChunk: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  [self send_getSyncChunk : authenticationToken afterUSN: afterUSN maxEntries: maxEntries fullSyncOnly: fullSyncOnly];
  return [self recv_getSyncChunk];
}

- (void) send_getFilteredSyncChunk: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries filter: (EDAMSyncChunkFilter *) filter
{
  [outProtocol writeMessageBeginWithName: @"getFilteredSyncChunk" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getFilteredSyncChunk_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: afterUSN];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: maxEntries];
  [outProtocol writeFieldEnd];
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 4];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncChunk *) recv_getFilteredSyncChunk
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetFilteredSyncChunk_result * result = [[[EDAMGetFilteredSyncChunk_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getFilteredSyncChunk failed: unknown result"];
}

- (EDAMSyncChunk *) getFilteredSyncChunk: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries filter: (EDAMSyncChunkFilter *) filter
{
  [self send_getFilteredSyncChunk : authenticationToken afterUSN: afterUSN maxEntries: maxEntries filter: filter];
  return [self recv_getFilteredSyncChunk];
}

- (void) send_getLinkedNotebookSyncState: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncState" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncState_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncState *) recv_getLinkedNotebookSyncState
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetLinkedNotebookSyncState_result * result = [[[EDAMGetLinkedNotebookSyncState_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getLinkedNotebookSyncState failed: unknown result"];
}

- (EDAMSyncState *) getLinkedNotebookSyncState: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_getLinkedNotebookSyncState : authenticationToken linkedNotebook: linkedNotebook];
  return [self recv_getLinkedNotebookSyncState];
}

- (void) send_getLinkedNotebookSyncChunk: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncChunk" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncChunk_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: afterUSN];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: maxEntries];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: fullSyncOnly];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncChunk *) recv_getLinkedNotebookSyncChunk
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetLinkedNotebookSyncChunk_result * result = [[[EDAMGetLinkedNotebookSyncChunk_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getLinkedNotebookSyncChunk failed: unknown result"];
}

- (EDAMSyncChunk *) getLinkedNotebookSyncChunk: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  [self send_getLinkedNotebookSyncChunk : authenticationToken linkedNotebook: linkedNotebook afterUSN: afterUSN maxEntries: maxEntries fullSyncOnly: fullSyncOnly];
  return [self recv_getLinkedNotebookSyncChunk];
}

- (void) send_listNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListNotebooks_result * result = [[[EDAMListNotebooks_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listNotebooks failed: unknown result"];
}

- (NSMutableArray *) listNotebooks: (NSString *) authenticationToken
{
  [self send_listNotebooks : authenticationToken];
  return [self recv_listNotebooks];
}

- (void) send_getNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNotebook_result * result = [[[EDAMGetNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNotebook failed: unknown result"];
}

- (EDAMNotebook *) getNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getNotebook : authenticationToken guid: guid];
  return [self recv_getNotebook];
}

- (void) send_getDefaultNotebook: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getDefaultNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getDefaultNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getDefaultNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetDefaultNotebook_result * result = [[[EDAMGetDefaultNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getDefaultNotebook failed: unknown result"];
}

- (EDAMNotebook *) getDefaultNotebook: (NSString *) authenticationToken
{
  [self send_getDefaultNotebook : authenticationToken];
  return [self recv_getDefaultNotebook];
}

- (void) send_createNotebook: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  [outProtocol writeMessageBeginWithName: @"createNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
    [notebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_createNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateNotebook_result * result = [[[EDAMCreateNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createNotebook failed: unknown result"];
}

- (EDAMNotebook *) createNotebook: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  [self send_createNotebook : authenticationToken notebook: notebook];
  return [self recv_createNotebook];
}

- (void) send_updateNotebook: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  [outProtocol writeMessageBeginWithName: @"updateNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
    [notebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateNotebook_result * result = [[[EDAMUpdateNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateNotebook failed: unknown result"];
}

- (int32_t) updateNotebook: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  [self send_updateNotebook : authenticationToken notebook: notebook];
  return [self recv_updateNotebook];
}

- (void) send_expungeNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNotebook_result * result = [[[EDAMExpungeNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNotebook failed: unknown result"];
}

- (int32_t) expungeNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_expungeNotebook : authenticationToken guid: guid];
  return [self recv_expungeNotebook];
}

- (void) send_listTags: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listTags" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listTags_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listTags
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListTags_result * result = [[[EDAMListTags_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listTags failed: unknown result"];
}

- (NSMutableArray *) listTags: (NSString *) authenticationToken
{
  [self send_listTags : authenticationToken];
  return [self recv_listTags];
}

- (void) send_listTagsByNotebook: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid
{
  [outProtocol writeMessageBeginWithName: @"listTagsByNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listTagsByNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: notebookGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listTagsByNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListTagsByNotebook_result * result = [[[EDAMListTagsByNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listTagsByNotebook failed: unknown result"];
}

- (NSMutableArray *) listTagsByNotebook: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid
{
  [self send_listTagsByNotebook : authenticationToken notebookGuid: notebookGuid];
  return [self recv_listTagsByNotebook];
}

- (void) send_getTag: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMTag *) recv_getTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetTag_result * result = [[[EDAMGetTag_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getTag failed: unknown result"];
}

- (EDAMTag *) getTag: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getTag : authenticationToken guid: guid];
  return [self recv_getTag];
}

- (void) send_createTag: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  [outProtocol writeMessageBeginWithName: @"createTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (tag != nil)  {
    [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
    [tag write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMTag *) recv_createTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateTag_result * result = [[[EDAMCreateTag_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createTag failed: unknown result"];
}

- (EDAMTag *) createTag: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  [self send_createTag : authenticationToken tag: tag];
  return [self recv_createTag];
}

- (void) send_updateTag: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  [outProtocol writeMessageBeginWithName: @"updateTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (tag != nil)  {
    [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
    [tag write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateTag_result * result = [[[EDAMUpdateTag_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateTag failed: unknown result"];
}

- (int32_t) updateTag: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  [self send_updateTag : authenticationToken tag: tag];
  return [self recv_updateTag];
}

- (void) send_untagAll: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"untagAll" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"untagAll_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_untagAll
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUntagAll_result * result = [[[EDAMUntagAll_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  return;
}

- (void) untagAll: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_untagAll : authenticationToken guid: guid];
  [self recv_untagAll];
}

- (void) send_expungeTag: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeTag_result * result = [[[EDAMExpungeTag_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeTag failed: unknown result"];
}

- (int32_t) expungeTag: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_expungeTag : authenticationToken guid: guid];
  return [self recv_expungeTag];
}

- (void) send_listSearches: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listSearches" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listSearches_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listSearches
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListSearches_result * result = [[[EDAMListSearches_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listSearches failed: unknown result"];
}

- (NSMutableArray *) listSearches: (NSString *) authenticationToken
{
  [self send_listSearches : authenticationToken];
  return [self recv_listSearches];
}

- (void) send_getSearch: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSavedSearch *) recv_getSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSearch_result * result = [[[EDAMGetSearch_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSearch failed: unknown result"];
}

- (EDAMSavedSearch *) getSearch: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getSearch : authenticationToken guid: guid];
  return [self recv_getSearch];
}

- (void) send_createSearch: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  [outProtocol writeMessageBeginWithName: @"createSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (search != nil)  {
    [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
    [search write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSavedSearch *) recv_createSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateSearch_result * result = [[[EDAMCreateSearch_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createSearch failed: unknown result"];
}

- (EDAMSavedSearch *) createSearch: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  [self send_createSearch : authenticationToken search: search];
  return [self recv_createSearch];
}

- (void) send_updateSearch: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  [outProtocol writeMessageBeginWithName: @"updateSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (search != nil)  {
    [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
    [search write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateSearch_result * result = [[[EDAMUpdateSearch_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateSearch failed: unknown result"];
}

- (int32_t) updateSearch: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  [self send_updateSearch : authenticationToken search: search];
  return [self recv_updateSearch];
}

- (void) send_expungeSearch: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeSearch_result * result = [[[EDAMExpungeSearch_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeSearch failed: unknown result"];
}

- (int32_t) expungeSearch: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_expungeSearch : authenticationToken guid: guid];
  return [self recv_expungeSearch];
}

- (void) send_findNotes: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes
{
  [outProtocol writeMessageBeginWithName: @"findNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: offset];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: maxNotes];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNoteList *) recv_findNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNotes_result * result = [[[EDAMFindNotes_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNotes failed: unknown result"];
}

- (EDAMNoteList *) findNotes: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes
{
  [self send_findNotes : authenticationToken filter: filter offset: offset maxNotes: maxNotes];
  return [self recv_findNotes];
}

- (void) send_findNoteOffset: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"findNoteOffset" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNoteOffset_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 3];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_findNoteOffset
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNoteOffset_result * result = [[[EDAMFindNoteOffset_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNoteOffset failed: unknown result"];
}

- (int32_t) findNoteOffset: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter guid: (EDAMGuid) guid
{
  [self send_findNoteOffset : authenticationToken filter: filter guid: guid];
  return [self recv_findNoteOffset];
}

- (void) send_findNotesMetadata: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes resultSpec: (EDAMNotesMetadataResultSpec *) resultSpec
{
  [outProtocol writeMessageBeginWithName: @"findNotesMetadata" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNotesMetadata_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: offset];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: maxNotes];
  [outProtocol writeFieldEnd];
  if (resultSpec != nil)  {
    [outProtocol writeFieldBeginWithName: @"resultSpec" type: TType_STRUCT fieldID: 5];
    [resultSpec write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotesMetadataList *) recv_findNotesMetadata
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNotesMetadata_result * result = [[[EDAMFindNotesMetadata_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNotesMetadata failed: unknown result"];
}

- (EDAMNotesMetadataList *) findNotesMetadata: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes resultSpec: (EDAMNotesMetadataResultSpec *) resultSpec
{
  [self send_findNotesMetadata : authenticationToken filter: filter offset: offset maxNotes: maxNotes resultSpec: resultSpec];
  return [self recv_findNotesMetadata];
}

- (void) send_findNoteCounts: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash
{
  [outProtocol writeMessageBeginWithName: @"findNoteCounts" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNoteCounts_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withTrash" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withTrash];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNoteCollectionCounts *) recv_findNoteCounts
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNoteCounts_result * result = [[[EDAMFindNoteCounts_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNoteCounts failed: unknown result"];
}

- (EDAMNoteCollectionCounts *) findNoteCounts: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash
{
  [self send_findNoteCounts : authenticationToken filter: filter withTrash: withTrash];
  return [self recv_findNoteCounts];
}

- (void) send_getNote: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withContent" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withContent];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withResourcesData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withResourcesRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withResourcesAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_getNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNote_result * result = [[[EDAMGetNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNote failed: unknown result"];
}

- (EDAMNote *) getNote: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  [self send_getNote : authenticationToken guid: guid withContent: withContent withResourcesData: withResourcesData withResourcesRecognition: withResourcesRecognition withResourcesAlternateData: withResourcesAlternateData];
  return [self recv_getNote];
}

- (void) send_getNoteApplicationData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteApplicationData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLazyMap *) recv_getNoteApplicationData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteApplicationData_result * result = [[[EDAMGetNoteApplicationData_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteApplicationData failed: unknown result"];
}

- (EDAMLazyMap *) getNoteApplicationData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getNoteApplicationData : authenticationToken guid: guid];
  return [self recv_getNoteApplicationData];
}

- (void) send_getNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteApplicationDataEntry_result * result = [[[EDAMGetNoteApplicationDataEntry_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteApplicationDataEntry failed: unknown result"];
}

- (NSString *) getNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [self send_getNoteApplicationDataEntry : authenticationToken guid: guid key: key];
  return [self recv_getNoteApplicationDataEntry];
}

- (void) send_setNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  [outProtocol writeMessageBeginWithName: @"setNoteApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"setNoteApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  if (value != nil)  {
    [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
    [outProtocol writeString: value];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_setNoteApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMSetNoteApplicationDataEntry_result * result = [[[EDAMSetNoteApplicationDataEntry_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"setNoteApplicationDataEntry failed: unknown result"];
}

- (int32_t) setNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  [self send_setNoteApplicationDataEntry : authenticationToken guid: guid key: key value: value];
  return [self recv_setNoteApplicationDataEntry];
}

- (void) send_unsetNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"unsetNoteApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"unsetNoteApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_unsetNoteApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUnsetNoteApplicationDataEntry_result * result = [[[EDAMUnsetNoteApplicationDataEntry_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"unsetNoteApplicationDataEntry failed: unknown result"];
}

- (int32_t) unsetNoteApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [self send_unsetNoteApplicationDataEntry : authenticationToken guid: guid key: key];
  return [self recv_unsetNoteApplicationDataEntry];
}

- (void) send_getNoteContent: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteContent" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteContent_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteContent
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteContent_result * result = [[[EDAMGetNoteContent_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteContent failed: unknown result"];
}

- (NSString *) getNoteContent: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getNoteContent : authenticationToken guid: guid];
  return [self recv_getNoteContent];
}

- (void) send_getNoteSearchText: (NSString *) authenticationToken guid: (EDAMGuid) guid noteOnly: (BOOL) noteOnly tokenizeForIndexing: (BOOL) tokenizeForIndexing
{
  [outProtocol writeMessageBeginWithName: @"getNoteSearchText" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteSearchText_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"noteOnly" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: noteOnly];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"tokenizeForIndexing" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: tokenizeForIndexing];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteSearchText
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteSearchText_result * result = [[[EDAMGetNoteSearchText_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteSearchText failed: unknown result"];
}

- (NSString *) getNoteSearchText: (NSString *) authenticationToken guid: (EDAMGuid) guid noteOnly: (BOOL) noteOnly tokenizeForIndexing: (BOOL) tokenizeForIndexing
{
  [self send_getNoteSearchText : authenticationToken guid: guid noteOnly: noteOnly tokenizeForIndexing: tokenizeForIndexing];
  return [self recv_getNoteSearchText];
}

- (void) send_getResourceSearchText: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceSearchText" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceSearchText_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getResourceSearchText
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceSearchText_result * result = [[[EDAMGetResourceSearchText_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceSearchText failed: unknown result"];
}

- (NSString *) getResourceSearchText: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getResourceSearchText : authenticationToken guid: guid];
  return [self recv_getResourceSearchText];
}

- (void) send_getNoteTagNames: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteTagNames" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteTagNames_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_getNoteTagNames
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteTagNames_result * result = [[[EDAMGetNoteTagNames_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteTagNames failed: unknown result"];
}

- (NSMutableArray *) getNoteTagNames: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getNoteTagNames : authenticationToken guid: guid];
  return [self recv_getNoteTagNames];
}

- (void) send_createNote: (NSString *) authenticationToken note: (EDAMNote *) note
{
  [outProtocol writeMessageBeginWithName: @"createNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (note != nil)  {
    [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
    [note write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_createNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateNote_result * result = [[[EDAMCreateNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createNote failed: unknown result"];
}

- (EDAMNote *) createNote: (NSString *) authenticationToken note: (EDAMNote *) note
{
  [self send_createNote : authenticationToken note: note];
  return [self recv_createNote];
}

- (void) send_updateNote: (NSString *) authenticationToken note: (EDAMNote *) note
{
  [outProtocol writeMessageBeginWithName: @"updateNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (note != nil)  {
    [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
    [note write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_updateNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateNote_result * result = [[[EDAMUpdateNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateNote failed: unknown result"];
}

- (EDAMNote *) updateNote: (NSString *) authenticationToken note: (EDAMNote *) note
{
  [self send_updateNote : authenticationToken note: note];
  return [self recv_updateNote];
}

- (void) send_deleteNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"deleteNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"deleteNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_deleteNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMDeleteNote_result * result = [[[EDAMDeleteNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"deleteNote failed: unknown result"];
}

- (int32_t) deleteNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_deleteNote : authenticationToken guid: guid];
  return [self recv_deleteNote];
}

- (void) send_expungeNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNote_result * result = [[[EDAMExpungeNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNote failed: unknown result"];
}

- (int32_t) expungeNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_expungeNote : authenticationToken guid: guid];
  return [self recv_expungeNote];
}

- (void) send_expungeNotes: (NSString *) authenticationToken noteGuids: (NSMutableArray *) noteGuids
{
  [outProtocol writeMessageBeginWithName: @"expungeNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuids != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuids" type: TType_LIST fieldID: 2];
    {
      [outProtocol writeListBeginWithElementType: TType_STRING size: [noteGuids count]];
      int i193;
      for (i193 = 0; i193 < [noteGuids count]; i193++)
      {
        [outProtocol writeString: [noteGuids objectAtIndex: i193]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNotes_result * result = [[[EDAMExpungeNotes_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNotes failed: unknown result"];
}

- (int32_t) expungeNotes: (NSString *) authenticationToken noteGuids: (NSMutableArray *) noteGuids
{
  [self send_expungeNotes : authenticationToken noteGuids: noteGuids];
  return [self recv_expungeNotes];
}

- (void) send_expungeInactiveNotes: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"expungeInactiveNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeInactiveNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeInactiveNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeInactiveNotes_result * result = [[[EDAMExpungeInactiveNotes_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeInactiveNotes failed: unknown result"];
}

- (int32_t) expungeInactiveNotes: (NSString *) authenticationToken
{
  [self send_expungeInactiveNotes : authenticationToken];
  return [self recv_expungeInactiveNotes];
}

- (void) send_copyNote: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid
{
  [outProtocol writeMessageBeginWithName: @"copyNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"copyNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  if (toNotebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"toNotebookGuid" type: TType_STRING fieldID: 3];
    [outProtocol writeString: toNotebookGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_copyNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCopyNote_result * result = [[[EDAMCopyNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"copyNote failed: unknown result"];
}

- (EDAMNote *) copyNote: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid
{
  [self send_copyNote : authenticationToken noteGuid: noteGuid toNotebookGuid: toNotebookGuid];
  return [self recv_copyNote];
}

- (void) send_listNoteVersions: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid
{
  [outProtocol writeMessageBeginWithName: @"listNoteVersions" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listNoteVersions_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listNoteVersions
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListNoteVersions_result * result = [[[EDAMListNoteVersions_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listNoteVersions failed: unknown result"];
}

- (NSMutableArray *) listNoteVersions: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid
{
  [self send_listNoteVersions : authenticationToken noteGuid: noteGuid];
  return [self recv_listNoteVersions];
}

- (void) send_getNoteVersion: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getNoteVersion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteVersion_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: updateSequenceNum];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withResourcesData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withResourcesRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withResourcesAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_getNoteVersion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteVersion_result * result = [[[EDAMGetNoteVersion_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteVersion failed: unknown result"];
}

- (EDAMNote *) getNoteVersion: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  [self send_getNoteVersion : authenticationToken noteGuid: noteGuid updateSequenceNum: updateSequenceNum withResourcesData: withResourcesData withResourcesRecognition: withResourcesRecognition withResourcesAlternateData: withResourcesAlternateData];
  return [self recv_getNoteVersion];
}

- (void) send_getResource: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getResource" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResource_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAttributes" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withAttributes];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResource *) recv_getResource
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResource_result * result = [[[EDAMGetResource_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResource failed: unknown result"];
}

- (EDAMResource *) getResource: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData
{
  [self send_getResource : authenticationToken guid: guid withData: withData withRecognition: withRecognition withAttributes: withAttributes withAlternateData: withAlternateData];
  return [self recv_getResource];
}

- (void) send_getResourceApplicationData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceApplicationData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLazyMap *) recv_getResourceApplicationData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceApplicationData_result * result = [[[EDAMGetResourceApplicationData_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceApplicationData failed: unknown result"];
}

- (EDAMLazyMap *) getResourceApplicationData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getResourceApplicationData : authenticationToken guid: guid];
  return [self recv_getResourceApplicationData];
}

- (void) send_getResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getResourceApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceApplicationDataEntry_result * result = [[[EDAMGetResourceApplicationDataEntry_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceApplicationDataEntry failed: unknown result"];
}

- (NSString *) getResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [self send_getResourceApplicationDataEntry : authenticationToken guid: guid key: key];
  return [self recv_getResourceApplicationDataEntry];
}

- (void) send_setResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  [outProtocol writeMessageBeginWithName: @"setResourceApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"setResourceApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  if (value != nil)  {
    [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
    [outProtocol writeString: value];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_setResourceApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMSetResourceApplicationDataEntry_result * result = [[[EDAMSetResourceApplicationDataEntry_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"setResourceApplicationDataEntry failed: unknown result"];
}

- (int32_t) setResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  [self send_setResourceApplicationDataEntry : authenticationToken guid: guid key: key value: value];
  return [self recv_setResourceApplicationDataEntry];
}

- (void) send_unsetResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"unsetResourceApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"unsetResourceApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_unsetResourceApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUnsetResourceApplicationDataEntry_result * result = [[[EDAMUnsetResourceApplicationDataEntry_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"unsetResourceApplicationDataEntry failed: unknown result"];
}

- (int32_t) unsetResourceApplicationDataEntry: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  [self send_unsetResourceApplicationDataEntry : authenticationToken guid: guid key: key];
  return [self recv_unsetResourceApplicationDataEntry];
}

- (void) send_updateResource: (NSString *) authenticationToken resource: (EDAMResource *) resource
{
  [outProtocol writeMessageBeginWithName: @"updateResource" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateResource_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (resource != nil)  {
    [outProtocol writeFieldBeginWithName: @"resource" type: TType_STRUCT fieldID: 2];
    [resource write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateResource
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateResource_result * result = [[[EDAMUpdateResource_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateResource failed: unknown result"];
}

- (int32_t) updateResource: (NSString *) authenticationToken resource: (EDAMResource *) resource
{
  [self send_updateResource : authenticationToken resource: resource];
  return [self recv_updateResource];
}

- (void) send_getResourceData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceData_result * result = [[[EDAMGetResourceData_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceData failed: unknown result"];
}

- (NSData *) getResourceData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getResourceData : authenticationToken guid: guid];
  return [self recv_getResourceData];
}

- (void) send_getResourceByHash: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getResourceByHash" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceByHash_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  if (contentHash != nil)  {
    [outProtocol writeFieldBeginWithName: @"contentHash" type: TType_STRING fieldID: 3];
    [outProtocol writeBinary: contentHash];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResource *) recv_getResourceByHash
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceByHash_result * result = [[[EDAMGetResourceByHash_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceByHash failed: unknown result"];
}

- (EDAMResource *) getResourceByHash: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData
{
  [self send_getResourceByHash : authenticationToken noteGuid: noteGuid contentHash: contentHash withData: withData withRecognition: withRecognition withAlternateData: withAlternateData];
  return [self recv_getResourceByHash];
}

- (void) send_getResourceRecognition: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceRecognition" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceRecognition_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceRecognition
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceRecognition_result * result = [[[EDAMGetResourceRecognition_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceRecognition failed: unknown result"];
}

- (NSData *) getResourceRecognition: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getResourceRecognition : authenticationToken guid: guid];
  return [self recv_getResourceRecognition];
}

- (void) send_getResourceAlternateData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceAlternateData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceAlternateData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceAlternateData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceAlternateData_result * result = [[[EDAMGetResourceAlternateData_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceAlternateData failed: unknown result"];
}

- (NSData *) getResourceAlternateData: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getResourceAlternateData : authenticationToken guid: guid];
  return [self recv_getResourceAlternateData];
}

- (void) send_getResourceAttributes: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceAttributes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceAttributes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResourceAttributes *) recv_getResourceAttributes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceAttributes_result * result = [[[EDAMGetResourceAttributes_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceAttributes failed: unknown result"];
}

- (EDAMResourceAttributes *) getResourceAttributes: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_getResourceAttributes : authenticationToken guid: guid];
  return [self recv_getResourceAttributes];
}

- (void) send_getPublicNotebook: (EDAMUserID) userId publicUri: (NSString *) publicUri
{
  [outProtocol writeMessageBeginWithName: @"getPublicNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getPublicNotebook_args"];
  [outProtocol writeFieldBeginWithName: @"userId" type: TType_I32 fieldID: 1];
  [outProtocol writeI32: userId];
  [outProtocol writeFieldEnd];
  if (publicUri != nil)  {
    [outProtocol writeFieldBeginWithName: @"publicUri" type: TType_STRING fieldID: 2];
    [outProtocol writeString: publicUri];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getPublicNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetPublicNotebook_result * result = [[[EDAMGetPublicNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getPublicNotebook failed: unknown result"];
}

- (EDAMNotebook *) getPublicNotebook: (EDAMUserID) userId publicUri: (NSString *) publicUri
{
  [self send_getPublicNotebook : userId publicUri: publicUri];
  return [self recv_getPublicNotebook];
}

- (void) send_createSharedNotebook: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  [outProtocol writeMessageBeginWithName: @"createSharedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createSharedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (sharedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
    [sharedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSharedNotebook *) recv_createSharedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateSharedNotebook_result * result = [[[EDAMCreateSharedNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createSharedNotebook failed: unknown result"];
}

- (EDAMSharedNotebook *) createSharedNotebook: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  [self send_createSharedNotebook : authenticationToken sharedNotebook: sharedNotebook];
  return [self recv_createSharedNotebook];
}

- (void) send_updateSharedNotebook: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  [outProtocol writeMessageBeginWithName: @"updateSharedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateSharedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (sharedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
    [sharedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateSharedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateSharedNotebook_result * result = [[[EDAMUpdateSharedNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateSharedNotebook failed: unknown result"];
}

- (int32_t) updateSharedNotebook: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  [self send_updateSharedNotebook : authenticationToken sharedNotebook: sharedNotebook];
  return [self recv_updateSharedNotebook];
}

- (void) send_sendMessageToSharedNotebookMembers: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid messageText: (NSString *) messageText recipients: (NSMutableArray *) recipients
{
  [outProtocol writeMessageBeginWithName: @"sendMessageToSharedNotebookMembers" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"sendMessageToSharedNotebookMembers_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: notebookGuid];
    [outProtocol writeFieldEnd];
  }
  if (messageText != nil)  {
    [outProtocol writeFieldBeginWithName: @"messageText" type: TType_STRING fieldID: 3];
    [outProtocol writeString: messageText];
    [outProtocol writeFieldEnd];
  }
  if (recipients != nil)  {
    [outProtocol writeFieldBeginWithName: @"recipients" type: TType_LIST fieldID: 4];
    {
      [outProtocol writeListBeginWithElementType: TType_STRING size: [recipients count]];
      int i195;
      for (i195 = 0; i195 < [recipients count]; i195++)
      {
        [outProtocol writeString: [recipients objectAtIndex: i195]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_sendMessageToSharedNotebookMembers
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMSendMessageToSharedNotebookMembers_result * result = [[[EDAMSendMessageToSharedNotebookMembers_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"sendMessageToSharedNotebookMembers failed: unknown result"];
}

- (int32_t) sendMessageToSharedNotebookMembers: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid messageText: (NSString *) messageText recipients: (NSMutableArray *) recipients
{
  [self send_sendMessageToSharedNotebookMembers : authenticationToken notebookGuid: notebookGuid messageText: messageText recipients: recipients];
  return [self recv_sendMessageToSharedNotebookMembers];
}

- (void) send_listSharedNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listSharedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listSharedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listSharedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListSharedNotebooks_result * result = [[[EDAMListSharedNotebooks_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listSharedNotebooks failed: unknown result"];
}

- (NSMutableArray *) listSharedNotebooks: (NSString *) authenticationToken
{
  [self send_listSharedNotebooks : authenticationToken];
  return [self recv_listSharedNotebooks];
}

- (void) send_expungeSharedNotebooks: (NSString *) authenticationToken sharedNotebookIds: (NSMutableArray *) sharedNotebookIds
{
  [outProtocol writeMessageBeginWithName: @"expungeSharedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeSharedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (sharedNotebookIds != nil)  {
    [outProtocol writeFieldBeginWithName: @"sharedNotebookIds" type: TType_LIST fieldID: 2];
    {
      [outProtocol writeListBeginWithElementType: TType_I64 size: [sharedNotebookIds count]];
      int i197;
      for (i197 = 0; i197 < [sharedNotebookIds count]; i197++)
      {
        [outProtocol writeI64: [[sharedNotebookIds objectAtIndex: i197] longLongValue]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeSharedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeSharedNotebooks_result * result = [[[EDAMExpungeSharedNotebooks_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeSharedNotebooks failed: unknown result"];
}

- (int32_t) expungeSharedNotebooks: (NSString *) authenticationToken sharedNotebookIds: (NSMutableArray *) sharedNotebookIds
{
  [self send_expungeSharedNotebooks : authenticationToken sharedNotebookIds: sharedNotebookIds];
  return [self recv_expungeSharedNotebooks];
}

- (void) send_createLinkedNotebook: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"createLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLinkedNotebook *) recv_createLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateLinkedNotebook_result * result = [[[EDAMCreateLinkedNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createLinkedNotebook failed: unknown result"];
}

- (EDAMLinkedNotebook *) createLinkedNotebook: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_createLinkedNotebook : authenticationToken linkedNotebook: linkedNotebook];
  return [self recv_createLinkedNotebook];
}

- (void) send_updateLinkedNotebook: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"updateLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateLinkedNotebook_result * result = [[[EDAMUpdateLinkedNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateLinkedNotebook failed: unknown result"];
}

- (int32_t) updateLinkedNotebook: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_updateLinkedNotebook : authenticationToken linkedNotebook: linkedNotebook];
  return [self recv_updateLinkedNotebook];
}

- (void) send_listLinkedNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listLinkedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listLinkedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listLinkedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListLinkedNotebooks_result * result = [[[EDAMListLinkedNotebooks_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listLinkedNotebooks failed: unknown result"];
}

- (NSMutableArray *) listLinkedNotebooks: (NSString *) authenticationToken
{
  [self send_listLinkedNotebooks : authenticationToken];
  return [self recv_listLinkedNotebooks];
}

- (void) send_expungeLinkedNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeLinkedNotebook_result * result = [[[EDAMExpungeLinkedNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeLinkedNotebook failed: unknown result"];
}

- (int32_t) expungeLinkedNotebook: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_expungeLinkedNotebook : authenticationToken guid: guid];
  return [self recv_expungeLinkedNotebook];
}

- (void) send_authenticateToSharedNotebook: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNotebook_args"];
  if (shareKey != nil)  {
    [outProtocol writeFieldBeginWithName: @"shareKey" type: TType_STRING fieldID: 1];
    [outProtocol writeString: shareKey];
    [outProtocol writeFieldEnd];
  }
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 2];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMAuthenticationResult *) recv_authenticateToSharedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMAuthenticateToSharedNotebook_result * result = [[[EDAMAuthenticateToSharedNotebook_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"authenticateToSharedNotebook failed: unknown result"];
}

- (EDAMAuthenticationResult *) authenticateToSharedNotebook: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken
{
  [self send_authenticateToSharedNotebook : shareKey authenticationToken: authenticationToken];
  return [self recv_authenticateToSharedNotebook];
}

- (void) send_getSharedNotebookByAuth: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getSharedNotebookByAuth" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSharedNotebookByAuth_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSharedNotebook *) recv_getSharedNotebookByAuth
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSharedNotebookByAuth_result * result = [[[EDAMGetSharedNotebookByAuth_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSharedNotebookByAuth failed: unknown result"];
}

- (EDAMSharedNotebook *) getSharedNotebookByAuth: (NSString *) authenticationToken
{
  [self send_getSharedNotebookByAuth : authenticationToken];
  return [self recv_getSharedNotebookByAuth];
}

- (void) send_emailNote: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters
{
  [outProtocol writeMessageBeginWithName: @"emailNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"emailNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (parameters != nil)  {
    [outProtocol writeFieldBeginWithName: @"parameters" type: TType_STRUCT fieldID: 2];
    [parameters write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_emailNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMEmailNote_result * result = [[[EDAMEmailNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  return;
}

- (void) emailNote: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters
{
  [self send_emailNote : authenticationToken parameters: parameters];
  [self recv_emailNote];
}

- (void) send_shareNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"shareNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"shareNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_shareNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMShareNote_result * result = [[[EDAMShareNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"shareNote failed: unknown result"];
}

- (NSString *) shareNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_shareNote : authenticationToken guid: guid];
  return [self recv_shareNote];
}

- (void) send_stopSharingNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"stopSharingNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"stopSharingNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_stopSharingNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMStopSharingNote_result * result = [[[EDAMStopSharingNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  return;
}

- (void) stopSharingNote: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  [self send_stopSharingNote : authenticationToken guid: guid];
  [self recv_stopSharingNote];
}

- (void) send_authenticateToSharedNote: (NSString *) guid noteKey: (NSString *) noteKey
{
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNote_args"];
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (noteKey != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteKey" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteKey];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMAuthenticationResult *) recv_authenticateToSharedNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMAuthenticateToSharedNote_result * result = [[[EDAMAuthenticateToSharedNote_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"authenticateToSharedNote failed: unknown result"];
}

- (EDAMAuthenticationResult *) authenticateToSharedNote: (NSString *) guid noteKey: (NSString *) noteKey
{
  [self send_authenticateToSharedNote : guid noteKey: noteKey];
  return [self recv_authenticateToSharedNote];
}

- (void) send_findRelated: (NSString *) authenticationToken query: (EDAMRelatedQuery *) query resultSpec: (EDAMRelatedResultSpec *) resultSpec
{
  [outProtocol writeMessageBeginWithName: @"findRelated" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findRelated_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (query != nil)  {
    [outProtocol writeFieldBeginWithName: @"query" type: TType_STRUCT fieldID: 2];
    [query write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (resultSpec != nil)  {
    [outProtocol writeFieldBeginWithName: @"resultSpec" type: TType_STRUCT fieldID: 3];
    [resultSpec write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMRelatedResult *) recv_findRelated
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindRelated_result * result = [[[EDAMFindRelated_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findRelated failed: unknown result"];
}

- (EDAMRelatedResult *) findRelated: (NSString *) authenticationToken query: (EDAMRelatedQuery *) query resultSpec: (EDAMRelatedResultSpec *) resultSpec
{
  [self send_findRelated : authenticationToken query: query resultSpec: resultSpec];
  return [self recv_findRelated];
}

@end

@implementation EDAMNoteStoreProcessor

- (id) initWithNoteStore: (id <EDAMNoteStore>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain_stub];
  mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
  {
    SEL s = @selector(process_getSyncState_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSyncState"];
  }
  {
    SEL s = @selector(process_getSyncStateWithMetrics_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSyncStateWithMetrics"];
  }
  {
    SEL s = @selector(process_getSyncChunk_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSyncChunk"];
  }
  {
    SEL s = @selector(process_getFilteredSyncChunk_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getFilteredSyncChunk"];
  }
  {
    SEL s = @selector(process_getLinkedNotebookSyncState_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getLinkedNotebookSyncState"];
  }
  {
    SEL s = @selector(process_getLinkedNotebookSyncChunk_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getLinkedNotebookSyncChunk"];
  }
  {
    SEL s = @selector(process_listNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listNotebooks"];
  }
  {
    SEL s = @selector(process_getNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNotebook"];
  }
  {
    SEL s = @selector(process_getDefaultNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getDefaultNotebook"];
  }
  {
    SEL s = @selector(process_createNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createNotebook"];
  }
  {
    SEL s = @selector(process_updateNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateNotebook"];
  }
  {
    SEL s = @selector(process_expungeNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNotebook"];
  }
  {
    SEL s = @selector(process_listTags_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listTags"];
  }
  {
    SEL s = @selector(process_listTagsByNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listTagsByNotebook"];
  }
  {
    SEL s = @selector(process_getTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getTag"];
  }
  {
    SEL s = @selector(process_createTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createTag"];
  }
  {
    SEL s = @selector(process_updateTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateTag"];
  }
  {
    SEL s = @selector(process_untagAll_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"untagAll"];
  }
  {
    SEL s = @selector(process_expungeTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeTag"];
  }
  {
    SEL s = @selector(process_listSearches_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listSearches"];
  }
  {
    SEL s = @selector(process_getSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSearch"];
  }
  {
    SEL s = @selector(process_createSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createSearch"];
  }
  {
    SEL s = @selector(process_updateSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateSearch"];
  }
  {
    SEL s = @selector(process_expungeSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeSearch"];
  }
  {
    SEL s = @selector(process_findNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNotes"];
  }
  {
    SEL s = @selector(process_findNoteOffset_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNoteOffset"];
  }
  {
    SEL s = @selector(process_findNotesMetadata_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNotesMetadata"];
  }
  {
    SEL s = @selector(process_findNoteCounts_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNoteCounts"];
  }
  {
    SEL s = @selector(process_getNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNote"];
  }
  {
    SEL s = @selector(process_getNoteApplicationData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteApplicationData"];
  }
  {
    SEL s = @selector(process_getNoteApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_setNoteApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"setNoteApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_unsetNoteApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"unsetNoteApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_getNoteContent_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteContent"];
  }
  {
    SEL s = @selector(process_getNoteSearchText_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteSearchText"];
  }
  {
    SEL s = @selector(process_getResourceSearchText_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceSearchText"];
  }
  {
    SEL s = @selector(process_getNoteTagNames_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteTagNames"];
  }
  {
    SEL s = @selector(process_createNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createNote"];
  }
  {
    SEL s = @selector(process_updateNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateNote"];
  }
  {
    SEL s = @selector(process_deleteNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"deleteNote"];
  }
  {
    SEL s = @selector(process_expungeNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNote"];
  }
  {
    SEL s = @selector(process_expungeNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNotes"];
  }
  {
    SEL s = @selector(process_expungeInactiveNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeInactiveNotes"];
  }
  {
    SEL s = @selector(process_copyNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"copyNote"];
  }
  {
    SEL s = @selector(process_listNoteVersions_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listNoteVersions"];
  }
  {
    SEL s = @selector(process_getNoteVersion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteVersion"];
  }
  {
    SEL s = @selector(process_getResource_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResource"];
  }
  {
    SEL s = @selector(process_getResourceApplicationData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceApplicationData"];
  }
  {
    SEL s = @selector(process_getResourceApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_setResourceApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"setResourceApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_unsetResourceApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"unsetResourceApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_updateResource_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateResource"];
  }
  {
    SEL s = @selector(process_getResourceData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceData"];
  }
  {
    SEL s = @selector(process_getResourceByHash_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceByHash"];
  }
  {
    SEL s = @selector(process_getResourceRecognition_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceRecognition"];
  }
  {
    SEL s = @selector(process_getResourceAlternateData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceAlternateData"];
  }
  {
    SEL s = @selector(process_getResourceAttributes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceAttributes"];
  }
  {
    SEL s = @selector(process_getPublicNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getPublicNotebook"];
  }
  {
    SEL s = @selector(process_createSharedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createSharedNotebook"];
  }
  {
    SEL s = @selector(process_updateSharedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateSharedNotebook"];
  }
  {
    SEL s = @selector(process_sendMessageToSharedNotebookMembers_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"sendMessageToSharedNotebookMembers"];
  }
  {
    SEL s = @selector(process_listSharedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listSharedNotebooks"];
  }
  {
    SEL s = @selector(process_expungeSharedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeSharedNotebooks"];
  }
  {
    SEL s = @selector(process_createLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createLinkedNotebook"];
  }
  {
    SEL s = @selector(process_updateLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateLinkedNotebook"];
  }
  {
    SEL s = @selector(process_listLinkedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listLinkedNotebooks"];
  }
  {
    SEL s = @selector(process_expungeLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeLinkedNotebook"];
  }
  {
    SEL s = @selector(process_authenticateToSharedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"authenticateToSharedNotebook"];
  }
  {
    SEL s = @selector(process_getSharedNotebookByAuth_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSharedNotebookByAuth"];
  }
  {
    SEL s = @selector(process_emailNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"emailNote"];
  }
  {
    SEL s = @selector(process_shareNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"shareNote"];
  }
  {
    SEL s = @selector(process_stopSharingNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"stopSharingNote"];
  }
  {
    SEL s = @selector(process_authenticateToSharedNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"authenticateToSharedNote"];
  }
  {
    SEL s = @selector(process_findRelated_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findRelated"];
  }
  return self;
}

- (id<EDAMNoteStore>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (__unsafe_unretained id <TProtocol>) inProtocol
                 outputProtocol: (__unsafe_unretained id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_getSyncState_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSyncState_args * args = [[EDAMgetSyncState_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSyncState_result * result = [[EDAMGetSyncState_result alloc] init];
  [result setSuccess: [mService getSyncState: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getSyncState"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getSyncStateWithMetrics_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSyncStateWithMetrics_args * args = [[EDAMgetSyncStateWithMetrics_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSyncStateWithMetrics_result * result = [[EDAMGetSyncStateWithMetrics_result alloc] init];
  [result setSuccess: [mService getSyncStateWithMetrics: [args authenticationToken] clientMetrics: [args clientMetrics]]];
  [outProtocol writeMessageBeginWithName: @"getSyncStateWithMetrics"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSyncChunk_args * args = [[EDAMgetSyncChunk_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSyncChunk_result * result = [[EDAMGetSyncChunk_result alloc] init];
  [result setSuccess: [mService getSyncChunk: [args authenticationToken] afterUSN: [args afterUSN] maxEntries: [args maxEntries] fullSyncOnly: [args fullSyncOnly]]];
  [outProtocol writeMessageBeginWithName: @"getSyncChunk"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getFilteredSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetFilteredSyncChunk_args * args = [[EDAMgetFilteredSyncChunk_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetFilteredSyncChunk_result * result = [[EDAMGetFilteredSyncChunk_result alloc] init];
  [result setSuccess: [mService getFilteredSyncChunk: [args authenticationToken] afterUSN: [args afterUSN] maxEntries: [args maxEntries] filter: [args filter]]];
  [outProtocol writeMessageBeginWithName: @"getFilteredSyncChunk"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getLinkedNotebookSyncState_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetLinkedNotebookSyncState_args * args = [[EDAMgetLinkedNotebookSyncState_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetLinkedNotebookSyncState_result * result = [[EDAMGetLinkedNotebookSyncState_result alloc] init];
  [result setSuccess: [mService getLinkedNotebookSyncState: [args authenticationToken] linkedNotebook: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncState"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getLinkedNotebookSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetLinkedNotebookSyncChunk_args * args = [[EDAMgetLinkedNotebookSyncChunk_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetLinkedNotebookSyncChunk_result * result = [[EDAMGetLinkedNotebookSyncChunk_result alloc] init];
  [result setSuccess: [mService getLinkedNotebookSyncChunk: [args authenticationToken] linkedNotebook: [args linkedNotebook] afterUSN: [args afterUSN] maxEntries: [args maxEntries] fullSyncOnly: [args fullSyncOnly]]];
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncChunk"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistNotebooks_args * args = [[EDAMlistNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListNotebooks_result * result = [[EDAMListNotebooks_result alloc] init];
  [result setSuccess: [mService listNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNotebook_args * args = [[EDAMgetNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNotebook_result * result = [[EDAMGetNotebook_result alloc] init];
  [result setSuccess: [mService getNotebook: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getDefaultNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetDefaultNotebook_args * args = [[EDAMgetDefaultNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetDefaultNotebook_result * result = [[EDAMGetDefaultNotebook_result alloc] init];
  [result setSuccess: [mService getDefaultNotebook: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getDefaultNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_createNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateNotebook_args * args = [[EDAMcreateNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateNotebook_result * result = [[EDAMCreateNotebook_result alloc] init];
  [result setSuccess: [mService createNotebook: [args authenticationToken] notebook: [args notebook]]];
  [outProtocol writeMessageBeginWithName: @"createNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateNotebook_args * args = [[EDAMupdateNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateNotebook_result * result = [[EDAMUpdateNotebook_result alloc] init];
  [result setSuccess: [mService updateNotebook: [args authenticationToken] notebook: [args notebook]]];
  [outProtocol writeMessageBeginWithName: @"updateNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNotebook_args * args = [[EDAMexpungeNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNotebook_result * result = [[EDAMExpungeNotebook_result alloc] init];
  [result setSuccess: [mService expungeNotebook: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listTags_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistTags_args * args = [[EDAMlistTags_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListTags_result * result = [[EDAMListTags_result alloc] init];
  [result setSuccess: [mService listTags: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listTags"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listTagsByNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistTagsByNotebook_args * args = [[EDAMlistTagsByNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListTagsByNotebook_result * result = [[EDAMListTagsByNotebook_result alloc] init];
  [result setSuccess: [mService listTagsByNotebook: [args authenticationToken] notebookGuid: [args notebookGuid]]];
  [outProtocol writeMessageBeginWithName: @"listTagsByNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetTag_args * args = [[EDAMgetTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetTag_result * result = [[EDAMGetTag_result alloc] init];
  [result setSuccess: [mService getTag: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_createTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateTag_args * args = [[EDAMcreateTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateTag_result * result = [[EDAMCreateTag_result alloc] init];
  [result setSuccess: [mService createTag: [args authenticationToken] tag: [args tag]]];
  [outProtocol writeMessageBeginWithName: @"createTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateTag_args * args = [[EDAMupdateTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateTag_result * result = [[EDAMUpdateTag_result alloc] init];
  [result setSuccess: [mService updateTag: [args authenticationToken] tag: [args tag]]];
  [outProtocol writeMessageBeginWithName: @"updateTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_untagAll_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMuntagAll_args * args = [[EDAMuntagAll_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUntagAll_result * result = [[EDAMUntagAll_result alloc] init];
  [mService untagAll: [args authenticationToken] guid: [args guid]];
  [outProtocol writeMessageBeginWithName: @"untagAll"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeTag_args * args = [[EDAMexpungeTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeTag_result * result = [[EDAMExpungeTag_result alloc] init];
  [result setSuccess: [mService expungeTag: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listSearches_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistSearches_args * args = [[EDAMlistSearches_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListSearches_result * result = [[EDAMListSearches_result alloc] init];
  [result setSuccess: [mService listSearches: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listSearches"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSearch_args * args = [[EDAMgetSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSearch_result * result = [[EDAMGetSearch_result alloc] init];
  [result setSuccess: [mService getSearch: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_createSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateSearch_args * args = [[EDAMcreateSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateSearch_result * result = [[EDAMCreateSearch_result alloc] init];
  [result setSuccess: [mService createSearch: [args authenticationToken] search: [args search]]];
  [outProtocol writeMessageBeginWithName: @"createSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateSearch_args * args = [[EDAMupdateSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateSearch_result * result = [[EDAMUpdateSearch_result alloc] init];
  [result setSuccess: [mService updateSearch: [args authenticationToken] search: [args search]]];
  [outProtocol writeMessageBeginWithName: @"updateSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeSearch_args * args = [[EDAMexpungeSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeSearch_result * result = [[EDAMExpungeSearch_result alloc] init];
  [result setSuccess: [mService expungeSearch: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_findNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNotes_args * args = [[EDAMfindNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNotes_result * result = [[EDAMFindNotes_result alloc] init];
  [result setSuccess: [mService findNotes: [args authenticationToken] filter: [args filter] offset: [args offset] maxNotes: [args maxNotes]]];
  [outProtocol writeMessageBeginWithName: @"findNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_findNoteOffset_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNoteOffset_args * args = [[EDAMfindNoteOffset_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNoteOffset_result * result = [[EDAMFindNoteOffset_result alloc] init];
  [result setSuccess: [mService findNoteOffset: [args authenticationToken] filter: [args filter] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"findNoteOffset"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_findNotesMetadata_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNotesMetadata_args * args = [[EDAMfindNotesMetadata_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNotesMetadata_result * result = [[EDAMFindNotesMetadata_result alloc] init];
  [result setSuccess: [mService findNotesMetadata: [args authenticationToken] filter: [args filter] offset: [args offset] maxNotes: [args maxNotes] resultSpec: [args resultSpec]]];
  [outProtocol writeMessageBeginWithName: @"findNotesMetadata"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_findNoteCounts_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNoteCounts_args * args = [[EDAMfindNoteCounts_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNoteCounts_result * result = [[EDAMFindNoteCounts_result alloc] init];
  [result setSuccess: [mService findNoteCounts: [args authenticationToken] filter: [args filter] withTrash: [args withTrash]]];
  [outProtocol writeMessageBeginWithName: @"findNoteCounts"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNote_args * args = [[EDAMgetNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNote_result * result = [[EDAMGetNote_result alloc] init];
  [result setSuccess: [mService getNote: [args authenticationToken] guid: [args guid] withContent: [args withContent] withResourcesData: [args withResourcesData] withResourcesRecognition: [args withResourcesRecognition] withResourcesAlternateData: [args withResourcesAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNoteApplicationData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteApplicationData_args * args = [[EDAMgetNoteApplicationData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteApplicationData_result * result = [[EDAMGetNoteApplicationData_result alloc] init];
  [result setSuccess: [mService getNoteApplicationData: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNoteApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteApplicationDataEntry_args * args = [[EDAMgetNoteApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteApplicationDataEntry_result * result = [[EDAMGetNoteApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService getNoteApplicationDataEntry: [args authenticationToken] guid: [args guid] key: [args key]]];
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_setNoteApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMsetNoteApplicationDataEntry_args * args = [[EDAMsetNoteApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMSetNoteApplicationDataEntry_result * result = [[EDAMSetNoteApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService setNoteApplicationDataEntry: [args authenticationToken] guid: [args guid] key: [args key] value: [args value]]];
  [outProtocol writeMessageBeginWithName: @"setNoteApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_unsetNoteApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMunsetNoteApplicationDataEntry_args * args = [[EDAMunsetNoteApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUnsetNoteApplicationDataEntry_result * result = [[EDAMUnsetNoteApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService unsetNoteApplicationDataEntry: [args authenticationToken] guid: [args guid] key: [args key]]];
  [outProtocol writeMessageBeginWithName: @"unsetNoteApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNoteContent_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteContent_args * args = [[EDAMgetNoteContent_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteContent_result * result = [[EDAMGetNoteContent_result alloc] init];
  [result setSuccess: [mService getNoteContent: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteContent"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNoteSearchText_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteSearchText_args * args = [[EDAMgetNoteSearchText_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteSearchText_result * result = [[EDAMGetNoteSearchText_result alloc] init];
  [result setSuccess: [mService getNoteSearchText: [args authenticationToken] guid: [args guid] noteOnly: [args noteOnly] tokenizeForIndexing: [args tokenizeForIndexing]]];
  [outProtocol writeMessageBeginWithName: @"getNoteSearchText"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceSearchText_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceSearchText_args * args = [[EDAMgetResourceSearchText_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceSearchText_result * result = [[EDAMGetResourceSearchText_result alloc] init];
  [result setSuccess: [mService getResourceSearchText: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceSearchText"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNoteTagNames_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteTagNames_args * args = [[EDAMgetNoteTagNames_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteTagNames_result * result = [[EDAMGetNoteTagNames_result alloc] init];
  [result setSuccess: [mService getNoteTagNames: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteTagNames"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_createNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateNote_args * args = [[EDAMcreateNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateNote_result * result = [[EDAMCreateNote_result alloc] init];
  [result setSuccess: [mService createNote: [args authenticationToken] note: [args note]]];
  [outProtocol writeMessageBeginWithName: @"createNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateNote_args * args = [[EDAMupdateNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateNote_result * result = [[EDAMUpdateNote_result alloc] init];
  [result setSuccess: [mService updateNote: [args authenticationToken] note: [args note]]];
  [outProtocol writeMessageBeginWithName: @"updateNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_deleteNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMdeleteNote_args * args = [[EDAMdeleteNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMDeleteNote_result * result = [[EDAMDeleteNote_result alloc] init];
  [result setSuccess: [mService deleteNote: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"deleteNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNote_args * args = [[EDAMexpungeNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNote_result * result = [[EDAMExpungeNote_result alloc] init];
  [result setSuccess: [mService expungeNote: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNotes_args * args = [[EDAMexpungeNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNotes_result * result = [[EDAMExpungeNotes_result alloc] init];
  [result setSuccess: [mService expungeNotes: [args authenticationToken] noteGuids: [args noteGuids]]];
  [outProtocol writeMessageBeginWithName: @"expungeNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeInactiveNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeInactiveNotes_args * args = [[EDAMexpungeInactiveNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeInactiveNotes_result * result = [[EDAMExpungeInactiveNotes_result alloc] init];
  [result setSuccess: [mService expungeInactiveNotes: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"expungeInactiveNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_copyNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcopyNote_args * args = [[EDAMcopyNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCopyNote_result * result = [[EDAMCopyNote_result alloc] init];
  [result setSuccess: [mService copyNote: [args authenticationToken] noteGuid: [args noteGuid] toNotebookGuid: [args toNotebookGuid]]];
  [outProtocol writeMessageBeginWithName: @"copyNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listNoteVersions_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistNoteVersions_args * args = [[EDAMlistNoteVersions_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListNoteVersions_result * result = [[EDAMListNoteVersions_result alloc] init];
  [result setSuccess: [mService listNoteVersions: [args authenticationToken] noteGuid: [args noteGuid]]];
  [outProtocol writeMessageBeginWithName: @"listNoteVersions"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getNoteVersion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteVersion_args * args = [[EDAMgetNoteVersion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteVersion_result * result = [[EDAMGetNoteVersion_result alloc] init];
  [result setSuccess: [mService getNoteVersion: [args authenticationToken] noteGuid: [args noteGuid] updateSequenceNum: [args updateSequenceNum] withResourcesData: [args withResourcesData] withResourcesRecognition: [args withResourcesRecognition] withResourcesAlternateData: [args withResourcesAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getNoteVersion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResource_args * args = [[EDAMgetResource_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResource_result * result = [[EDAMGetResource_result alloc] init];
  [result setSuccess: [mService getResource: [args authenticationToken] guid: [args guid] withData: [args withData] withRecognition: [args withRecognition] withAttributes: [args withAttributes] withAlternateData: [args withAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getResource"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceApplicationData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceApplicationData_args * args = [[EDAMgetResourceApplicationData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceApplicationData_result * result = [[EDAMGetResourceApplicationData_result alloc] init];
  [result setSuccess: [mService getResourceApplicationData: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceApplicationDataEntry_args * args = [[EDAMgetResourceApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceApplicationDataEntry_result * result = [[EDAMGetResourceApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService getResourceApplicationDataEntry: [args authenticationToken] guid: [args guid] key: [args key]]];
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_setResourceApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMsetResourceApplicationDataEntry_args * args = [[EDAMsetResourceApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMSetResourceApplicationDataEntry_result * result = [[EDAMSetResourceApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService setResourceApplicationDataEntry: [args authenticationToken] guid: [args guid] key: [args key] value: [args value]]];
  [outProtocol writeMessageBeginWithName: @"setResourceApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_unsetResourceApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMunsetResourceApplicationDataEntry_args * args = [[EDAMunsetResourceApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUnsetResourceApplicationDataEntry_result * result = [[EDAMUnsetResourceApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService unsetResourceApplicationDataEntry: [args authenticationToken] guid: [args guid] key: [args key]]];
  [outProtocol writeMessageBeginWithName: @"unsetResourceApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateResource_args * args = [[EDAMupdateResource_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateResource_result * result = [[EDAMUpdateResource_result alloc] init];
  [result setSuccess: [mService updateResource: [args authenticationToken] resource: [args resource]]];
  [outProtocol writeMessageBeginWithName: @"updateResource"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceData_args * args = [[EDAMgetResourceData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceData_result * result = [[EDAMGetResourceData_result alloc] init];
  [result setSuccess: [mService getResourceData: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceByHash_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceByHash_args * args = [[EDAMgetResourceByHash_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceByHash_result * result = [[EDAMGetResourceByHash_result alloc] init];
  [result setSuccess: [mService getResourceByHash: [args authenticationToken] noteGuid: [args noteGuid] contentHash: [args contentHash] withData: [args withData] withRecognition: [args withRecognition] withAlternateData: [args withAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getResourceByHash"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceRecognition_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceRecognition_args * args = [[EDAMgetResourceRecognition_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceRecognition_result * result = [[EDAMGetResourceRecognition_result alloc] init];
  [result setSuccess: [mService getResourceRecognition: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceRecognition"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceAlternateData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceAlternateData_args * args = [[EDAMgetResourceAlternateData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceAlternateData_result * result = [[EDAMGetResourceAlternateData_result alloc] init];
  [result setSuccess: [mService getResourceAlternateData: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceAlternateData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getResourceAttributes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceAttributes_args * args = [[EDAMgetResourceAttributes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceAttributes_result * result = [[EDAMGetResourceAttributes_result alloc] init];
  [result setSuccess: [mService getResourceAttributes: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceAttributes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getPublicNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetPublicNotebook_args * args = [[EDAMgetPublicNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetPublicNotebook_result * result = [[EDAMGetPublicNotebook_result alloc] init];
  [result setSuccess: [mService getPublicNotebook: [args userId] publicUri: [args publicUri]]];
  [outProtocol writeMessageBeginWithName: @"getPublicNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_createSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateSharedNotebook_args * args = [[EDAMcreateSharedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateSharedNotebook_result * result = [[EDAMCreateSharedNotebook_result alloc] init];
  [result setSuccess: [mService createSharedNotebook: [args authenticationToken] sharedNotebook: [args sharedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"createSharedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateSharedNotebook_args * args = [[EDAMupdateSharedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateSharedNotebook_result * result = [[EDAMUpdateSharedNotebook_result alloc] init];
  [result setSuccess: [mService updateSharedNotebook: [args authenticationToken] sharedNotebook: [args sharedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"updateSharedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_sendMessageToSharedNotebookMembers_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMsendMessageToSharedNotebookMembers_args * args = [[EDAMsendMessageToSharedNotebookMembers_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMSendMessageToSharedNotebookMembers_result * result = [[EDAMSendMessageToSharedNotebookMembers_result alloc] init];
  [result setSuccess: [mService sendMessageToSharedNotebookMembers: [args authenticationToken] notebookGuid: [args notebookGuid] messageText: [args messageText] recipients: [args recipients]]];
  [outProtocol writeMessageBeginWithName: @"sendMessageToSharedNotebookMembers"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistSharedNotebooks_args * args = [[EDAMlistSharedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListSharedNotebooks_result * result = [[EDAMListSharedNotebooks_result alloc] init];
  [result setSuccess: [mService listSharedNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listSharedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeSharedNotebooks_args * args = [[EDAMexpungeSharedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeSharedNotebooks_result * result = [[EDAMExpungeSharedNotebooks_result alloc] init];
  [result setSuccess: [mService expungeSharedNotebooks: [args authenticationToken] sharedNotebookIds: [args sharedNotebookIds]]];
  [outProtocol writeMessageBeginWithName: @"expungeSharedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_createLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateLinkedNotebook_args * args = [[EDAMcreateLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateLinkedNotebook_result * result = [[EDAMCreateLinkedNotebook_result alloc] init];
  [result setSuccess: [mService createLinkedNotebook: [args authenticationToken] linkedNotebook: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"createLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateLinkedNotebook_args * args = [[EDAMupdateLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateLinkedNotebook_result * result = [[EDAMUpdateLinkedNotebook_result alloc] init];
  [result setSuccess: [mService updateLinkedNotebook: [args authenticationToken] linkedNotebook: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"updateLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listLinkedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistLinkedNotebooks_args * args = [[EDAMlistLinkedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListLinkedNotebooks_result * result = [[EDAMListLinkedNotebooks_result alloc] init];
  [result setSuccess: [mService listLinkedNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listLinkedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_expungeLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeLinkedNotebook_args * args = [[EDAMexpungeLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeLinkedNotebook_result * result = [[EDAMExpungeLinkedNotebook_result alloc] init];
  [result setSuccess: [mService expungeLinkedNotebook: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_authenticateToSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMauthenticateToSharedNotebook_args * args = [[EDAMauthenticateToSharedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMAuthenticateToSharedNotebook_result * result = [[EDAMAuthenticateToSharedNotebook_result alloc] init];
  [result setSuccess: [mService authenticateToSharedNotebook: [args shareKey] authenticationToken: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getSharedNotebookByAuth_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSharedNotebookByAuth_args * args = [[EDAMgetSharedNotebookByAuth_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSharedNotebookByAuth_result * result = [[EDAMGetSharedNotebookByAuth_result alloc] init];
  [result setSuccess: [mService getSharedNotebookByAuth: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getSharedNotebookByAuth"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_emailNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMemailNote_args * args = [[EDAMemailNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMEmailNote_result * result = [[EDAMEmailNote_result alloc] init];
  [mService emailNote: [args authenticationToken] parameters: [args parameters]];
  [outProtocol writeMessageBeginWithName: @"emailNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_shareNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMshareNote_args * args = [[EDAMshareNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMShareNote_result * result = [[EDAMShareNote_result alloc] init];
  [result setSuccess: [mService shareNote: [args authenticationToken] guid: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"shareNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_stopSharingNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMstopSharingNote_args * args = [[EDAMstopSharingNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMStopSharingNote_result * result = [[EDAMStopSharingNote_result alloc] init];
  [mService stopSharingNote: [args authenticationToken] guid: [args guid]];
  [outProtocol writeMessageBeginWithName: @"stopSharingNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_authenticateToSharedNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMauthenticateToSharedNote_args * args = [[EDAMauthenticateToSharedNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMAuthenticateToSharedNote_result * result = [[EDAMAuthenticateToSharedNote_result alloc] init];
  [result setSuccess: [mService authenticateToSharedNote: [args guid] noteKey: [args noteKey]]];
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_findRelated_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindRelated_args * args = [[EDAMfindRelated_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindRelated_result * result = [[EDAMFindRelated_result alloc] init];
  [result setSuccess: [mService findRelated: [args authenticationToken] query: [args query] resultSpec: [args resultSpec]]];
  [outProtocol writeMessageBeginWithName: @"findRelated"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) dealloc
{
  [mService release_stub];
  [mMethodMap release_stub];
  [super dealloc_stub];
}

@end

